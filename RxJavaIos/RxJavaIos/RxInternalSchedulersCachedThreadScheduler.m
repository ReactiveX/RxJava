//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel-doppl/RxJava/src/main/java/rx/internal/schedulers/CachedThreadScheduler.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "RxFunctionsAction0.h"
#include "RxInternalSchedulersCachedThreadScheduler.h"
#include "RxInternalSchedulersNewThreadWorker.h"
#include "RxInternalSchedulersScheduledAction.h"
#include "RxInternalUtilRxThreadFactory.h"
#include "RxScheduler.h"
#include "RxSubscription.h"
#include "RxSubscriptionsCompositeSubscription.h"
#include "RxSubscriptionsSubscriptions.h"
#include "java/lang/Runnable.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/util/List.h"
#include "java/util/concurrent/ConcurrentLinkedQueue.h"
#include "java/util/concurrent/Executors.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/ScheduledExecutorService.h"
#include "java/util/concurrent/ScheduledFuture.h"
#include "java/util/concurrent/ThreadFactory.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

inline jlong RxInternalSchedulersCachedThreadScheduler_get_KEEP_ALIVE_TIME();
#define RxInternalSchedulersCachedThreadScheduler_KEEP_ALIVE_TIME 60LL
J2OBJC_STATIC_FIELD_CONSTANT(RxInternalSchedulersCachedThreadScheduler, KEEP_ALIVE_TIME, jlong)

inline JavaUtilConcurrentTimeUnit *RxInternalSchedulersCachedThreadScheduler_get_KEEP_ALIVE_UNIT();
static JavaUtilConcurrentTimeUnit *RxInternalSchedulersCachedThreadScheduler_KEEP_ALIVE_UNIT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersCachedThreadScheduler, KEEP_ALIVE_UNIT, JavaUtilConcurrentTimeUnit *)

@interface RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool () {
 @public
  id<JavaUtilConcurrentThreadFactory> threadFactory_;
  jlong keepAliveTime_;
  JavaUtilConcurrentConcurrentLinkedQueue *expiringWorkerQueue_;
  RxSubscriptionsCompositeSubscription *allWorkers_;
  id<JavaUtilConcurrentScheduledExecutorService> evictorService_;
  id<JavaUtilConcurrentFuture> evictorTask_;
}

@end

J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool, threadFactory_, id<JavaUtilConcurrentThreadFactory>)
J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool, expiringWorkerQueue_, JavaUtilConcurrentConcurrentLinkedQueue *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool, allWorkers_, RxSubscriptionsCompositeSubscription *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool, evictorService_, id<JavaUtilConcurrentScheduledExecutorService>)
J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool, evictorTask_, id<JavaUtilConcurrentFuture>)

@interface RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 : NSObject < JavaUtilConcurrentThreadFactory > {
 @public
  id<JavaUtilConcurrentThreadFactory> val$threadFactory_;
}

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r OBJC_METHOD_FAMILY_NONE;

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)capture$0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1)

J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1, val$threadFactory_, id<JavaUtilConcurrentThreadFactory>)

__attribute__((unused)) static void RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 *self, id<JavaUtilConcurrentThreadFactory> capture$0);

__attribute__((unused)) static RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 *new_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 *create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> capture$0);

@interface RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 : NSObject < JavaLangRunnable > {
 @public
  RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *this$0_;
}

- (void)run;

- (instancetype)initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool:(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2)

J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2, this$0_, RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *)

__attribute__((unused)) static void RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 *self, RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *outer$);

__attribute__((unused)) static RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 *new_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 *create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *outer$);

@interface RxInternalSchedulersCachedThreadScheduler_EventLoopWorker () {
 @public
  RxSubscriptionsCompositeSubscription *innerSubscription_;
  RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *pool_;
  RxInternalSchedulersCachedThreadScheduler_ThreadWorker *threadWorker_;
}

@end

J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker, innerSubscription_, RxSubscriptionsCompositeSubscription *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker, pool_, RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker, threadWorker_, RxInternalSchedulersCachedThreadScheduler_ThreadWorker *)

@interface RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 : NSObject < RxFunctionsAction0 > {
 @public
  RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *this$0_;
  id<RxFunctionsAction0> val$action_;
}

- (void)call;

- (instancetype)initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker:(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *)outer$
                                                           withRxFunctionsAction0:(id<RxFunctionsAction0>)capture$0;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1)

J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1, this$0_, RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1, val$action_, id<RxFunctionsAction0>)

__attribute__((unused)) static void RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 *self, RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0);

__attribute__((unused)) static RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 *new_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 *create_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0);

@interface RxInternalSchedulersCachedThreadScheduler_ThreadWorker () {
 @public
  jlong expirationTime_;
}

@end

J2OBJC_INITIALIZED_DEFN(RxInternalSchedulersCachedThreadScheduler)

RxInternalSchedulersCachedThreadScheduler_ThreadWorker *RxInternalSchedulersCachedThreadScheduler_SHUTDOWN_THREADWORKER;
RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *RxInternalSchedulersCachedThreadScheduler_NONE;

@implementation RxInternalSchedulersCachedThreadScheduler

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  RxInternalSchedulersCachedThreadScheduler_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

- (void)start {
  RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *update = create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_(threadFactory_, RxInternalSchedulersCachedThreadScheduler_KEEP_ALIVE_TIME, RxInternalSchedulersCachedThreadScheduler_KEEP_ALIVE_UNIT);
  if (![((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) compareAndSetWithId:RxInternalSchedulersCachedThreadScheduler_NONE withId:update]) {
    [update shutdown];
  }
}

- (void)shutdown {
  for (; ; ) {
    RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *curr = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get];
    if (curr == RxInternalSchedulersCachedThreadScheduler_NONE) {
      return;
    }
    if ([pool_ compareAndSetWithId:curr withId:RxInternalSchedulersCachedThreadScheduler_NONE]) {
      [((RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *) nil_chk(curr)) shutdown];
      return;
    }
  }
}

- (RxScheduler_Worker *)createWorker {
  return create_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get]);
}

- (void)dealloc {
  RELEASE_(threadFactory_);
  RELEASE_(pool_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  methods[1].selector = @selector(start);
  methods[2].selector = @selector(shutdown);
  methods[3].selector = @selector(createWorker);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "KEEP_ALIVE_TIME", "J", .constantValue.asLong = RxInternalSchedulersCachedThreadScheduler_KEEP_ALIVE_TIME, 0x1a, -1, -1, -1, -1 },
    { "KEEP_ALIVE_UNIT", "LJavaUtilConcurrentTimeUnit;", .constantValue.asLong = 0, 0x1a, -1, 1, -1, -1 },
    { "SHUTDOWN_THREADWORKER", "LRxInternalSchedulersCachedThreadScheduler_ThreadWorker;", .constantValue.asLong = 0, 0x18, -1, 2, -1, -1 },
    { "NONE", "LRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;", .constantValue.asLong = 0, 0x18, -1, 3, -1, -1 },
    { "threadFactory_", "LJavaUtilConcurrentThreadFactory;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "pool_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x10, -1, -1, 4, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;", &RxInternalSchedulersCachedThreadScheduler_KEEP_ALIVE_UNIT, &RxInternalSchedulersCachedThreadScheduler_SHUTDOWN_THREADWORKER, &RxInternalSchedulersCachedThreadScheduler_NONE, "Ljava/util/concurrent/atomic/AtomicReference<Lrx/internal/schedulers/CachedThreadScheduler$CachedWorkerPool;>;", "LRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;LRxInternalSchedulersCachedThreadScheduler_EventLoopWorker;LRxInternalSchedulersCachedThreadScheduler_ThreadWorker;" };
  static const J2ObjcClassInfo _RxInternalSchedulersCachedThreadScheduler = { "CachedThreadScheduler", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x11, 4, 6, -1, 5, -1, -1, -1 };
  return &_RxInternalSchedulersCachedThreadScheduler;
}

+ (void)initialize {
  if (self == [RxInternalSchedulersCachedThreadScheduler class]) {
    JreStrongAssign(&RxInternalSchedulersCachedThreadScheduler_KEEP_ALIVE_UNIT, JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS));
    {
      JreStrongAssignAndConsume(&RxInternalSchedulersCachedThreadScheduler_SHUTDOWN_THREADWORKER, new_RxInternalSchedulersCachedThreadScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(JreLoadStatic(RxInternalUtilRxThreadFactory, NONE)));
      [RxInternalSchedulersCachedThreadScheduler_SHUTDOWN_THREADWORKER unsubscribe];
      JreStrongAssignAndConsume(&RxInternalSchedulersCachedThreadScheduler_NONE, new_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_(nil, 0, nil));
      [RxInternalSchedulersCachedThreadScheduler_NONE shutdown];
    }
    J2OBJC_SET_INITIALIZED(RxInternalSchedulersCachedThreadScheduler)
  }
}

@end

void RxInternalSchedulersCachedThreadScheduler_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersCachedThreadScheduler *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  RxScheduler_init(self);
  JreStrongAssign(&self->threadFactory_, threadFactory);
  JreStrongAssignAndConsume(&self->pool_, new_JavaUtilConcurrentAtomicAtomicReference_initWithId_(RxInternalSchedulersCachedThreadScheduler_NONE));
  [self start];
}

RxInternalSchedulersCachedThreadScheduler *new_RxInternalSchedulersCachedThreadScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersCachedThreadScheduler, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

RxInternalSchedulersCachedThreadScheduler *create_RxInternalSchedulersCachedThreadScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersCachedThreadScheduler, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersCachedThreadScheduler)

@implementation RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory
                                               withLong:(jlong)keepAliveTime
                         withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_(self, threadFactory, keepAliveTime, unit);
  return self;
}

- (RxInternalSchedulersCachedThreadScheduler_ThreadWorker *)get {
  if ([((RxSubscriptionsCompositeSubscription *) nil_chk(allWorkers_)) isUnsubscribed]) {
    return JreLoadStatic(RxInternalSchedulersCachedThreadScheduler, SHUTDOWN_THREADWORKER);
  }
  while (![((JavaUtilConcurrentConcurrentLinkedQueue *) nil_chk(expiringWorkerQueue_)) isEmpty]) {
    RxInternalSchedulersCachedThreadScheduler_ThreadWorker *threadWorker = [expiringWorkerQueue_ poll];
    if (threadWorker != nil) {
      return threadWorker;
    }
  }
  RxInternalSchedulersCachedThreadScheduler_ThreadWorker *w = create_RxInternalSchedulersCachedThreadScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(threadFactory_);
  [allWorkers_ addWithRxSubscription:w];
  return w;
}

- (void)release__WithRxInternalSchedulersCachedThreadScheduler_ThreadWorker:(RxInternalSchedulersCachedThreadScheduler_ThreadWorker *)threadWorker {
  [((RxInternalSchedulersCachedThreadScheduler_ThreadWorker *) nil_chk(threadWorker)) setExpirationTimeWithLong:[self now] + keepAliveTime_];
  [((JavaUtilConcurrentConcurrentLinkedQueue *) nil_chk(expiringWorkerQueue_)) offerWithId:threadWorker];
}

- (void)evictExpiredWorkers {
  if (![((JavaUtilConcurrentConcurrentLinkedQueue *) nil_chk(expiringWorkerQueue_)) isEmpty]) {
    jlong currentTimestamp = [self now];
    for (RxInternalSchedulersCachedThreadScheduler_ThreadWorker * __strong threadWorker in expiringWorkerQueue_) {
      if ([((RxInternalSchedulersCachedThreadScheduler_ThreadWorker *) nil_chk(threadWorker)) getExpirationTime] <= currentTimestamp) {
        if ([expiringWorkerQueue_ removeWithId:threadWorker]) {
          [((RxSubscriptionsCompositeSubscription *) nil_chk(allWorkers_)) removeWithRxSubscription:threadWorker];
        }
      }
      else {
        break;
      }
    }
  }
}

- (jlong)now {
  return JavaLangSystem_nanoTime();
}

- (void)shutdown {
  @try {
    if (evictorTask_ != nil) {
      [evictorTask_ cancelWithBoolean:true];
    }
    if (evictorService_ != nil) {
      [evictorService_ shutdownNow];
    }
  }
  @finally {
    [((RxSubscriptionsCompositeSubscription *) nil_chk(allWorkers_)) unsubscribe];
  }
}

- (void)dealloc {
  RELEASE_(threadFactory_);
  RELEASE_(expiringWorkerQueue_);
  RELEASE_(allWorkers_);
  RELEASE_(evictorService_);
  RELEASE_(evictorTask_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LRxInternalSchedulersCachedThreadScheduler_ThreadWorker;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentThreadFactory:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[1].selector = @selector(get);
  methods[2].selector = @selector(release__WithRxInternalSchedulersCachedThreadScheduler_ThreadWorker:);
  methods[3].selector = @selector(evictExpiredWorkers);
  methods[4].selector = @selector(now);
  methods[5].selector = @selector(shutdown);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "threadFactory_", "LJavaUtilConcurrentThreadFactory;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "keepAliveTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "expiringWorkerQueue_", "LJavaUtilConcurrentConcurrentLinkedQueue;", .constantValue.asLong = 0, 0x12, -1, -1, 3, -1 },
    { "allWorkers_", "LRxSubscriptionsCompositeSubscription;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "evictorService_", "LJavaUtilConcurrentScheduledExecutorService;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "evictorTask_", "LJavaUtilConcurrentFuture;", .constantValue.asLong = 0, 0x12, -1, -1, 4, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;JLJavaUtilConcurrentTimeUnit;", "release", "LRxInternalSchedulersCachedThreadScheduler_ThreadWorker;", "Ljava/util/concurrent/ConcurrentLinkedQueue<Lrx/internal/schedulers/CachedThreadScheduler$ThreadWorker;>;", "Ljava/util/concurrent/Future<*>;", "LRxInternalSchedulersCachedThreadScheduler;" };
  static const J2ObjcClassInfo _RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool = { "CachedWorkerPool", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 6, 6, 5, -1, -1, -1, -1 };
  return &_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;
}

@end

void RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *self, id<JavaUtilConcurrentThreadFactory> threadFactory, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit) {
  NSObject_init(self);
  JreStrongAssign(&self->threadFactory_, threadFactory);
  self->keepAliveTime_ = unit != nil ? [unit toNanosWithLong:keepAliveTime] : 0LL;
  JreStrongAssignAndConsume(&self->expiringWorkerQueue_, new_JavaUtilConcurrentConcurrentLinkedQueue_init());
  JreStrongAssignAndConsume(&self->allWorkers_, new_RxSubscriptionsCompositeSubscription_init());
  id<JavaUtilConcurrentScheduledExecutorService> evictor = nil;
  id<JavaUtilConcurrentFuture> task = nil;
  if (unit != nil) {
    evictor = JavaUtilConcurrentExecutors_newScheduledThreadPoolWithInt_withJavaUtilConcurrentThreadFactory_(1, create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(threadFactory));
    RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(evictor);
    task = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(evictor)) scheduleWithFixedDelayWithJavaLangRunnable:create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(self) withLong:self->keepAliveTime_ withLong:self->keepAliveTime_ withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
  }
  JreStrongAssign(&self->evictorService_, evictor);
  JreStrongAssign(&self->evictorTask_, task);
}

RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *new_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaUtilConcurrentThreadFactory> threadFactory, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool, initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_, threadFactory, keepAliveTime, unit)
}

RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaUtilConcurrentThreadFactory> threadFactory, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool, initWithJavaUtilConcurrentThreadFactory_withLong_withJavaUtilConcurrentTimeUnit_, threadFactory, keepAliveTime, unit)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool)

@implementation RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r {
  JavaLangThread *thread = [((id<JavaUtilConcurrentThreadFactory>) nil_chk(val$threadFactory_)) newThreadWithJavaLangRunnable:r];
  [((JavaLangThread *) nil_chk(thread)) setNameWithNSString:JreStrcat("$$", [thread getName], @" (Evictor)")];
  return thread;
}

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)capture$0 {
  RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(self, capture$0);
  return self;
}

- (void)dealloc {
  RELEASE_(val$threadFactory_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LJavaLangThread;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(newThreadWithJavaLangRunnable:);
  methods[1].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$threadFactory_", "LJavaUtilConcurrentThreadFactory;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "newThread", "LJavaLangRunnable;", "LJavaUtilConcurrentThreadFactory;", "LRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;", "initWithJavaUtilConcurrentThreadFactory:withLong:withJavaUtilConcurrentTimeUnit:" };
  static const J2ObjcClassInfo _RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 = { "", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x8008, 2, 1, 3, -1, 4, -1, -1 };
  return &_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1;
}

@end

void RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 *self, id<JavaUtilConcurrentThreadFactory> capture$0) {
  JreStrongAssign(&self->val$threadFactory_, capture$0);
  NSObject_init(self);
}

RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 *new_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> capture$0) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1, initWithJavaUtilConcurrentThreadFactory_, capture$0)
}

RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1 *create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> capture$0) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$1, initWithJavaUtilConcurrentThreadFactory_, capture$0)
}

@implementation RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2

- (void)run {
  [this$0_ evictExpiredWorkers];
}

- (instancetype)initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool:(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *)outer$ {
  RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(self, outer$);
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(run);
  methods[1].selector = @selector(initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;", "initWithJavaUtilConcurrentThreadFactory:withLong:withJavaUtilConcurrentTimeUnit:" };
  static const J2ObjcClassInfo _RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 = { "", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x8008, 2, 1, 0, -1, 1, -1, -1 };
  return &_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2;
}

@end

void RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 *self, RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
}

RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 *new_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *outer$) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2, initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_, outer$)
}

RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2 *create_RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *outer$) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_$2, initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_, outer$)
}

@implementation RxInternalSchedulersCachedThreadScheduler_EventLoopWorker

- (instancetype)initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool:(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *)pool {
  RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(self, pool);
  return self;
}

- (void)unsubscribe {
  if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(once_)) compareAndSetWithBoolean:false withBoolean:true]) {
    [((RxInternalSchedulersCachedThreadScheduler_ThreadWorker *) nil_chk(threadWorker_)) scheduleWithRxFunctionsAction0:self];
  }
  [((RxSubscriptionsCompositeSubscription *) nil_chk(innerSubscription_)) unsubscribe];
}

- (void)call {
  [((RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *) nil_chk(pool_)) release__WithRxInternalSchedulersCachedThreadScheduler_ThreadWorker:threadWorker_];
}

- (jboolean)isUnsubscribed {
  return [((RxSubscriptionsCompositeSubscription *) nil_chk(innerSubscription_)) isUnsubscribed];
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action {
  return [self scheduleWithRxFunctionsAction0:action withLong:0 withJavaUtilConcurrentTimeUnit:nil];
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if ([((RxSubscriptionsCompositeSubscription *) nil_chk(innerSubscription_)) isUnsubscribed]) {
    return RxSubscriptionsSubscriptions_unsubscribed();
  }
  RxInternalSchedulersScheduledAction *s = [((RxInternalSchedulersCachedThreadScheduler_ThreadWorker *) nil_chk(threadWorker_)) scheduleActualWithRxFunctionsAction0:create_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(self, action) withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
  [innerSubscription_ addWithRxSubscription:s];
  [((RxInternalSchedulersScheduledAction *) nil_chk(s)) addParentWithRxSubscriptionsCompositeSubscription:innerSubscription_];
  return s;
}

- (void)dealloc {
  RELEASE_(innerSubscription_);
  RELEASE_(pool_);
  RELEASE_(threadWorker_);
  RELEASE_(once_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 1, 3, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool:);
  methods[1].selector = @selector(unsubscribe);
  methods[2].selector = @selector(call);
  methods[3].selector = @selector(isUnsubscribed);
  methods[4].selector = @selector(scheduleWithRxFunctionsAction0:);
  methods[5].selector = @selector(scheduleWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "innerSubscription_", "LRxSubscriptionsCompositeSubscription;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pool_", "LRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "threadWorker_", "LRxInternalSchedulersCachedThreadScheduler_ThreadWorker;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "once_", "LJavaUtilConcurrentAtomicAtomicBoolean;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool;", "schedule", "LRxFunctionsAction0;", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;", "LRxInternalSchedulersCachedThreadScheduler;" };
  static const J2ObjcClassInfo _RxInternalSchedulersCachedThreadScheduler_EventLoopWorker = { "EventLoopWorker", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 6, 4, 4, -1, -1, -1, -1 };
  return &_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker;
}

@end

void RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *self, RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *pool) {
  RxScheduler_Worker_init(self);
  JreStrongAssignAndConsume(&self->innerSubscription_, new_RxSubscriptionsCompositeSubscription_init());
  JreStrongAssign(&self->pool_, pool);
  JreStrongAssignAndConsume(&self->once_, new_JavaUtilConcurrentAtomicAtomicBoolean_init());
  JreStrongAssign(&self->threadWorker_, [((RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *) nil_chk(pool)) get]);
}

RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *new_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *pool) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker, initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_, pool)
}

RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *create_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_(RxInternalSchedulersCachedThreadScheduler_CachedWorkerPool *pool) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker, initWithRxInternalSchedulersCachedThreadScheduler_CachedWorkerPool_, pool)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker)

@implementation RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1

- (void)call {
  if ([this$0_ isUnsubscribed]) {
    return;
  }
  [((id<RxFunctionsAction0>) nil_chk(val$action_)) call];
}

- (instancetype)initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker:(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *)outer$
                                                           withRxFunctionsAction0:(id<RxFunctionsAction0>)capture$0 {
  RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(self, outer$, capture$0);
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(call);
  methods[1].selector = @selector(initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker:withRxFunctionsAction0:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LRxInternalSchedulersCachedThreadScheduler_EventLoopWorker;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$action_", "LRxFunctionsAction0;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxInternalSchedulersCachedThreadScheduler_EventLoopWorker;LRxFunctionsAction0;", "LRxInternalSchedulersCachedThreadScheduler_EventLoopWorker;", "scheduleWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:" };
  static const J2ObjcClassInfo _RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 = { "", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x8008, 2, 2, 1, -1, 2, -1, -1 };
  return &_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1;
}

@end

void RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 *self, RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  JreStrongAssign(&self->this$0_, outer$);
  JreStrongAssign(&self->val$action_, capture$0);
  NSObject_init(self);
}

RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 *new_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1, initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_, outer$, capture$0)
}

RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1 *create_RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1_initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersCachedThreadScheduler_EventLoopWorker_$1, initWithRxInternalSchedulersCachedThreadScheduler_EventLoopWorker_withRxFunctionsAction0_, outer$, capture$0)
}

@implementation RxInternalSchedulersCachedThreadScheduler_ThreadWorker

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  RxInternalSchedulersCachedThreadScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

- (jlong)getExpirationTime {
  return expirationTime_;
}

- (void)setExpirationTimeWithLong:(jlong)expirationTime {
  self->expirationTime_ = expirationTime;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  methods[1].selector = @selector(getExpirationTime);
  methods[2].selector = @selector(setExpirationTimeWithLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "expirationTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;", "setExpirationTime", "J", "LRxInternalSchedulersCachedThreadScheduler;" };
  static const J2ObjcClassInfo _RxInternalSchedulersCachedThreadScheduler_ThreadWorker = { "ThreadWorker", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 3, 1, 3, -1, -1, -1, -1 };
  return &_RxInternalSchedulersCachedThreadScheduler_ThreadWorker;
}

@end

void RxInternalSchedulersCachedThreadScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersCachedThreadScheduler_ThreadWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  self->expirationTime_ = 0LL;
}

RxInternalSchedulersCachedThreadScheduler_ThreadWorker *new_RxInternalSchedulersCachedThreadScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersCachedThreadScheduler_ThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

RxInternalSchedulersCachedThreadScheduler_ThreadWorker *create_RxInternalSchedulersCachedThreadScheduler_ThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersCachedThreadScheduler_ThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersCachedThreadScheduler_ThreadWorker)
