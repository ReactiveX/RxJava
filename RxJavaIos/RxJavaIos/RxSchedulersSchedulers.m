//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel-doppl/RxJava/src/main/java/rx/schedulers/Schedulers.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "RxInternalSchedulersExecutorScheduler.h"
#include "RxInternalSchedulersGenericScheduledExecutorService.h"
#include "RxInternalSchedulersImmediateScheduler.h"
#include "RxInternalSchedulersSchedulerLifecycle.h"
#include "RxInternalSchedulersTrampolineScheduler.h"
#include "RxInternalUtilObjectPool.h"
#include "RxInternalUtilRxRingBuffer.h"
#include "RxPluginsRxJavaHooks.h"
#include "RxPluginsRxJavaPlugins.h"
#include "RxPluginsRxJavaSchedulersHook.h"
#include "RxScheduler.h"
#include "RxSchedulersSchedulers.h"
#include "RxSchedulersTestScheduler.h"
#include "java/util/concurrent/Executor.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

@interface RxSchedulersSchedulers () {
 @public
  RxScheduler *computationScheduler_;
  RxScheduler *ioScheduler_;
  RxScheduler *newThreadScheduler_;
}

+ (RxSchedulersSchedulers *)getInstance;

- (instancetype)init;

@end

J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, computationScheduler_, RxScheduler *)
J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, ioScheduler_, RxScheduler *)
J2OBJC_FIELD_SETTER(RxSchedulersSchedulers, newThreadScheduler_, RxScheduler *)

inline JavaUtilConcurrentAtomicAtomicReference *RxSchedulersSchedulers_get_INSTANCE();
static JavaUtilConcurrentAtomicAtomicReference *RxSchedulersSchedulers_INSTANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxSchedulersSchedulers, INSTANCE, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static RxSchedulersSchedulers *RxSchedulersSchedulers_getInstance();

__attribute__((unused)) static void RxSchedulersSchedulers_init(RxSchedulersSchedulers *self);

__attribute__((unused)) static RxSchedulersSchedulers *new_RxSchedulersSchedulers_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxSchedulersSchedulers *create_RxSchedulersSchedulers_init();

J2OBJC_INITIALIZED_DEFN(RxSchedulersSchedulers)

@implementation RxSchedulersSchedulers

+ (RxSchedulersSchedulers *)getInstance {
  return RxSchedulersSchedulers_getInstance();
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxSchedulersSchedulers_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (RxScheduler *)immediate {
  return RxSchedulersSchedulers_immediate();
}

+ (RxScheduler *)trampoline {
  return RxSchedulersSchedulers_trampoline();
}

+ (RxScheduler *)newThread {
  return RxSchedulersSchedulers_newThread();
}

+ (RxScheduler *)computation {
  return RxSchedulersSchedulers_computation();
}

+ (RxScheduler *)io {
  return RxSchedulersSchedulers_io();
}

+ (RxSchedulersTestScheduler *)test {
  return RxSchedulersSchedulers_test();
}

+ (RxScheduler *)fromWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor {
  return RxSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(executor);
}

+ (void)reset {
  RxSchedulersSchedulers_reset();
}

+ (void)start {
  RxSchedulersSchedulers_start();
}

+ (void)shutdown {
  RxSchedulersSchedulers_shutdown();
}

- (void)startInstance {
  @synchronized(self) {
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:computationScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(computationScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) start];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:ioScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(ioScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) start];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:newThreadScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(newThreadScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) start];
    }
  }
}

- (void)shutdownInstance {
  @synchronized(self) {
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:computationScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(computationScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) shutdown];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:ioScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(ioScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) shutdown];
    }
    if ([RxInternalSchedulersSchedulerLifecycle_class_() isInstance:newThreadScheduler_]) {
      [((id<RxInternalSchedulersSchedulerLifecycle>) nil_chk(((id<RxInternalSchedulersSchedulerLifecycle>) cast_check(newThreadScheduler_, RxInternalSchedulersSchedulerLifecycle_class_())))) shutdown];
    }
  }
}

- (void)dealloc {
  RELEASE_(computationScheduler_);
  RELEASE_(ioScheduler_);
  RELEASE_(newThreadScheduler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LRxSchedulersSchedulers;", 0xa, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxSchedulersTestScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x20, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x20, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(getInstance);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(immediate);
  methods[3].selector = @selector(trampoline);
  methods[4].selector = @selector(newThread);
  methods[5].selector = @selector(computation);
  methods[6].selector = @selector(io);
  methods[7].selector = @selector(test);
  methods[8].selector = @selector(fromWithJavaUtilConcurrentExecutor:);
  methods[9].selector = @selector(reset);
  methods[10].selector = @selector(start);
  methods[11].selector = @selector(shutdown);
  methods[12].selector = @selector(startInstance);
  methods[13].selector = @selector(shutdownInstance);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "computationScheduler_", "LRxScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "ioScheduler_", "LRxScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "newThreadScheduler_", "LRxScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "INSTANCE", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1a, -1, 2, 3, -1 },
  };
  static const void *ptrTable[] = { "from", "LJavaUtilConcurrentExecutor;", &RxSchedulersSchedulers_INSTANCE, "Ljava/util/concurrent/atomic/AtomicReference<Lrx/schedulers/Schedulers;>;" };
  static const J2ObjcClassInfo _RxSchedulersSchedulers = { "Schedulers", "rx.schedulers", ptrTable, methods, fields, 7, 0x11, 14, 4, -1, -1, -1, -1, -1 };
  return &_RxSchedulersSchedulers;
}

+ (void)initialize {
  if (self == [RxSchedulersSchedulers class]) {
    JreStrongAssignAndConsume(&RxSchedulersSchedulers_INSTANCE, new_JavaUtilConcurrentAtomicAtomicReference_init());
    J2OBJC_SET_INITIALIZED(RxSchedulersSchedulers)
  }
}

@end

RxSchedulersSchedulers *RxSchedulersSchedulers_getInstance() {
  RxSchedulersSchedulers_initialize();
  for (; ; ) {
    RxSchedulersSchedulers *current = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxSchedulersSchedulers_INSTANCE)) get];
    if (current != nil) {
      return current;
    }
    current = create_RxSchedulersSchedulers_init();
    if ([RxSchedulersSchedulers_INSTANCE compareAndSetWithId:nil withId:current]) {
      return current;
    }
    else {
      [current shutdownInstance];
    }
  }
}

void RxSchedulersSchedulers_init(RxSchedulersSchedulers *self) {
  NSObject_init(self);
  RxPluginsRxJavaSchedulersHook *hook = [((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getSchedulersHook];
  RxScheduler *c = [((RxPluginsRxJavaSchedulersHook *) nil_chk(hook)) getComputationScheduler];
  if (c != nil) {
    JreStrongAssign(&self->computationScheduler_, c);
  }
  else {
    JreStrongAssign(&self->computationScheduler_, RxPluginsRxJavaSchedulersHook_createComputationScheduler());
  }
  RxScheduler *io = [hook getIOScheduler];
  if (io != nil) {
    JreStrongAssign(&self->ioScheduler_, io);
  }
  else {
    JreStrongAssign(&self->ioScheduler_, RxPluginsRxJavaSchedulersHook_createIoScheduler());
  }
  RxScheduler *nt = [hook getNewThreadScheduler];
  if (nt != nil) {
    JreStrongAssign(&self->newThreadScheduler_, nt);
  }
  else {
    JreStrongAssign(&self->newThreadScheduler_, RxPluginsRxJavaSchedulersHook_createNewThreadScheduler());
  }
}

RxSchedulersSchedulers *new_RxSchedulersSchedulers_init() {
  J2OBJC_NEW_IMPL(RxSchedulersSchedulers, init)
}

RxSchedulersSchedulers *create_RxSchedulersSchedulers_init() {
  J2OBJC_CREATE_IMPL(RxSchedulersSchedulers, init)
}

RxScheduler *RxSchedulersSchedulers_immediate() {
  RxSchedulersSchedulers_initialize();
  return JreLoadStatic(RxInternalSchedulersImmediateScheduler, INSTANCE);
}

RxScheduler *RxSchedulersSchedulers_trampoline() {
  RxSchedulersSchedulers_initialize();
  return JreLoadStatic(RxInternalSchedulersTrampolineScheduler, INSTANCE);
}

RxScheduler *RxSchedulersSchedulers_newThread() {
  RxSchedulersSchedulers_initialize();
  return RxPluginsRxJavaHooks_onNewThreadSchedulerWithRxScheduler_(((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_getInstance()))->newThreadScheduler_);
}

RxScheduler *RxSchedulersSchedulers_computation() {
  RxSchedulersSchedulers_initialize();
  return RxPluginsRxJavaHooks_onComputationSchedulerWithRxScheduler_(((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_getInstance()))->computationScheduler_);
}

RxScheduler *RxSchedulersSchedulers_io() {
  RxSchedulersSchedulers_initialize();
  return RxPluginsRxJavaHooks_onIOSchedulerWithRxScheduler_(((RxSchedulersSchedulers *) nil_chk(RxSchedulersSchedulers_getInstance()))->ioScheduler_);
}

RxSchedulersTestScheduler *RxSchedulersSchedulers_test() {
  RxSchedulersSchedulers_initialize();
  return create_RxSchedulersTestScheduler_init();
}

RxScheduler *RxSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor) {
  RxSchedulersSchedulers_initialize();
  return create_RxInternalSchedulersExecutorScheduler_initWithJavaUtilConcurrentExecutor_(executor);
}

void RxSchedulersSchedulers_reset() {
  RxSchedulersSchedulers_initialize();
  RxSchedulersSchedulers *s = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxSchedulersSchedulers_INSTANCE)) getAndSetWithId:nil];
  if (s != nil) {
    [s shutdownInstance];
  }
}

void RxSchedulersSchedulers_start() {
  RxSchedulersSchedulers_initialize();
  RxSchedulersSchedulers *s = RxSchedulersSchedulers_getInstance();
  [((RxSchedulersSchedulers *) nil_chk(s)) startInstance];
  @synchronized(s) {
    [((RxInternalSchedulersGenericScheduledExecutorService *) nil_chk(JreLoadStatic(RxInternalSchedulersGenericScheduledExecutorService, INSTANCE))) start];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPSC_POOL))) start];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPMC_POOL))) start];
  }
}

void RxSchedulersSchedulers_shutdown() {
  RxSchedulersSchedulers_initialize();
  RxSchedulersSchedulers *s = RxSchedulersSchedulers_getInstance();
  [((RxSchedulersSchedulers *) nil_chk(s)) shutdownInstance];
  @synchronized(s) {
    [((RxInternalSchedulersGenericScheduledExecutorService *) nil_chk(JreLoadStatic(RxInternalSchedulersGenericScheduledExecutorService, INSTANCE))) shutdown];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPSC_POOL))) shutdown];
    [((RxInternalUtilObjectPool *) nil_chk(JreLoadStatic(RxInternalUtilRxRingBuffer, SPMC_POOL))) shutdown];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxSchedulersSchedulers)
