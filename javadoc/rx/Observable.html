<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_37) on Thu Jan 31 16:38:57 PST 2013 -->
<TITLE>
Observable (RxJava Javadoc 0.1)
</TITLE>

<META NAME="date" CONTENT="2013-01-31">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../javadocStyleSheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Observable (RxJava Javadoc 0.1)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../rx/Notification.Kind.html" title="enum in rx"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../rx/Observer.html" title="interface in rx"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?rx/Observable.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Observable.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
rx</FONT>
<BR>
Class Observable&lt;T&gt;</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>rx.Observable&lt;T&gt;</B>
</PRE>
<DL>
<DT><DT><B>Type Parameters:</B><DD><CODE>T</CODE> - </DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../rx/subjects/Subject.html" title="class in rx.subjects">Subject</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Observable&lt;T&gt;</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
The Observable interface that implements the Reactive Pattern.
 <p>
 The documentation for this interface makes use of marble diagrams. The following legend explains
 these diagrams:
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.legend&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.legend.png"></a>
 <p>
 It provides overloaded methods for subscribing as well as delegate methods to the
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#Observable()">Observable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#Observable(rx.util.functions.Func1)">Observable</A></B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A>&gt;&nbsp;onSubscribe)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#concat(rx.Observable...)">concat</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;...&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines the objects emitted by two or more Observables, and emits the result as a single Observable,
 by using the <code>concat</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#create(rx.util.functions.Func1)">create</A></B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;T&gt;,<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A>&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a Observable that will execute the given function when a Observer subscribes to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#create(java.lang.Object)">create</A></B>(java.lang.Object&nbsp;callback)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a Observable that will execute the given function when a Observer subscribes to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#createSubscription(rx.util.functions.Action0)">createSubscription</A></B>(<A HREF="../rx/util/functions/Action0.html" title="interface in rx.util.functions">Action0</A>&nbsp;unsubscribe)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Subscription implemented via a Func
 
 //TODO should this be moved to a Subscriptions utility class?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#createSubscription(java.lang.Object)">createSubscription</A></B>(java.lang.Object&nbsp;unsubscribe)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Subscription implemented via an anonymous function (such as closures from other languages).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#empty()">empty</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that returns no data to the Observer and immediately invokes its <code>onCompleted</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#error(java.lang.Exception)">error</A></B>(java.lang.Exception&nbsp;exception)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that calls <code>onError</code> when a Observer subscribes to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#filter(rx.util.functions.Func1)">filter</A></B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filters a Observable by discarding any of its emissions that do not meet some test.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#filter(java.lang.Object)">filter</A></B>(java.lang.Object&nbsp;callback)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filters a Observable by discarding any of its emissions that do not meet some test.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#filter(rx.Observable, rx.util.functions.Func1)">filter</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
       <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;T,java.lang.Boolean&gt;&nbsp;predicate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filters a Observable by discarding any of its emissions that do not meet some test.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#filter(rx.Observable, java.lang.Object)">filter</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
       java.lang.Object&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filters a Observable by discarding any of its emissions that do not meet some test.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(java.lang.Iterable)">from</A></B>(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Iterable sequence to a Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#from(T...)">from</A></B>(T...&nbsp;items)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Array sequence to a Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#just(T)">just</A></B>(T&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that notifies an observer of a single value and then completes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#last()">last</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a Observable that emits a sequence of objects into one that only emits the last
 object in this sequence before completing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#last(rx.Observable)">last</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Takes the last item emitted by a source Observable and returns a Observable that emits only
 that item as its sole emission.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#map(rx.util.functions.Func1)">map</A></B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,R&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies a closure of your choosing to every item emitted by a Observable, and returns this
 transformation as a new Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#map(java.lang.Object)">map</A></B>(java.lang.Object&nbsp;callback)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies a closure of your choosing to every item emitted by a Observable, and returns this
 transformation as a new Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#map(rx.Observable, rx.util.functions.Func1)">map</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
    <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;T,R&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies a closure of your choosing to every notification emitted by a Observable, and returns
 this transformation as a new Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#map(rx.Observable, java.lang.Object)">map</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
    java.lang.Object&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies a closure of your choosing to every notification emitted by a Observable, and returns
 this transformation as a new Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mapMany(rx.util.functions.Func1)">mapMany</A></B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new Observable sequence by applying a closure that you supply to each item in the
 original Observable sequence, where that closure is itself a Observable that emits items, and
 then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mapMany(java.lang.Object)">mapMany</A></B>(java.lang.Object&nbsp;callback)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new Observable sequence by applying a closure that you supply to each item in the
 original Observable sequence, where that closure is itself a Observable that emits items, and
 then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mapMany(rx.Observable, rx.util.functions.Func1)">mapMany</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
        <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;T,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new Observable sequence by applying a closure that you supply to each object in the
 original Observable sequence, where that closure is itself a Observable that emits objects,
 and then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mapMany(rx.Observable, java.lang.Object)">mapMany</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
        java.lang.Object&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new Observable sequence by applying a closure that you supply to each object in the
 original Observable sequence, where that closure is itself a Observable that emits objects,
 and then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#materialize()">materialize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Materializes the implicit notifications of this observable sequence as explicit notification values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#materialize(rx.Observable)">materialize</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Materializes the implicit notifications of an observable sequence as explicit notification values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(java.util.List)">merge</A></B>(java.util.List&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens the Observable sequences from a list of Observables into one Observable sequence
 without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens the Observable sequences emitted by a sequence of Observables that are emitted by a
 Observable into one Observable sequence without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#merge(rx.Observable...)">merge</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;...&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flattens the Observable sequences from a series of Observables into one Observable sequence
 without any transformation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(java.util.List)">mergeDelayError</A></B>(java.util.List&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same functionality as <code>merge</code> except that errors received to onError will be held until all sequences have finished (onComplete/onError) before sending the error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same functionality as <code>merge</code> except that errors received to onError will be held until all sequences have finished (onComplete/onError) before sending the error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#mergeDelayError(rx.Observable...)">mergeDelayError</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;...&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Same functionality as <code>merge</code> except that errors received to onError will be held until all sequences have finished (onComplete/onError) before sending the error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#never()">never</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that never sends any information to a Observer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#noOpSubscription()">noOpSubscription</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A ObservableSubscription that does nothing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(rx.util.functions.Func1)">onErrorResumeNext</A></B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to pass control to another Observable rather than calling <code>onError</code> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(java.lang.Object)">onErrorResumeNext</A></B>(java.lang.Object&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to emit a particular item rather than calling <code>onError</code> if
 it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(rx.Observable)">onErrorResumeNext</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeSequence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to pass control to another Observable rather than calling
 <code>onError</code> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(rx.Observable, rx.util.functions.Func1)">onErrorResumeNext</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                  <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to pass control to another Observable (the return value of a function)
 rather than calling <code>onError</code> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(rx.Observable, java.lang.Object)">onErrorResumeNext</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                  java.lang.Object&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to emit a particular object (as returned by a closure) to its Observer
 rather than calling <code>onError</code> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorResumeNext(rx.Observable, rx.Observable)">onErrorResumeNext</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;resumeSequence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to pass control to another Observable rather than calling <code>onError</code> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorReturn(rx.util.functions.Func1)">onErrorReturn</A></B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to emit a particular item rather than calling <code>onError</code> if
 it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorReturn(java.lang.Object)">onErrorReturn</A></B>(java.lang.Object&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to emit a particular item rather than calling <code>onError</code> if
 it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#onErrorReturn(rx.Observable, rx.util.functions.Func1)">onErrorReturn</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
              <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,T&gt;&nbsp;resumeFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruct a Observable to emit a particular item to its Observer's <code>onNext</code> closure
 rather than calling <code>onError</code> if it encounters an error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(rx.util.functions.Func2)">reduce</A></B>(<A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(java.lang.Object)">reduce</A></B>(java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(rx.Observable, rx.util.functions.Func2)">reduce</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
       <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(rx.Observable, java.lang.Object)">reduce</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
       java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(rx.Observable, T, rx.util.functions.Func2)">reduce</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
       T&nbsp;initialValue,
       <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(rx.Observable, T, java.lang.Object)">reduce</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
       T&nbsp;initialValue,
       java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(T, rx.util.functions.Func2)">reduce</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
       <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#reduce(T, java.lang.Object)">reduce</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
       java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(rx.util.functions.Func2)">scan</A></B>(<A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(java.lang.Object)">scan</A></B>(java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(rx.Observable, rx.util.functions.Func2)">scan</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
     <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(rx.Observable, java.lang.Object)">scan</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
     java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(rx.Observable, T, rx.util.functions.Func2)">scan</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
     T&nbsp;initialValue,
     <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(rx.Observable, T, java.lang.Object)">scan</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
     T&nbsp;initialValue,
     java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(T, rx.util.functions.Func2)">scan</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
     <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#scan(T, java.lang.Object)">scan</A></B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
     java.lang.Object&nbsp;accumulator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, then feeds the result of that closure along with the
 third item into the same closure, and so on, emitting the result of each of these
 iterations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skip(int)">skip</A></B>(int&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that skips the first <code>num</code> items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#skip(rx.Observable, int)">skip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;items,
     int&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that skips the first <code>num</code> items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.util.functions.Action1)">subscribe</A></B>(<A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.util.functions.Action1, rx.util.functions.Action1)">subscribe</A></B>(<A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
          <A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;java.lang.Exception&gt;&nbsp;onError)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.util.functions.Action1, rx.util.functions.Action1, rx.util.functions.Action0)">subscribe</A></B>(<A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
          <A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;java.lang.Exception&gt;&nbsp;onError,
          <A HREF="../rx/util/functions/Action0.html" title="interface in rx.util.functions">Action0</A>&nbsp;onComplete)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(java.util.Map)">subscribe</A></B>(java.util.Map&lt;java.lang.String,java.lang.Object&gt;&nbsp;callbacks)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(java.lang.Object)">subscribe</A></B>(java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(java.lang.Object, java.lang.Object)">subscribe</A></B>(java.lang.Object&nbsp;onNext,
          java.lang.Object&nbsp;onError)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(java.lang.Object, java.lang.Object, java.lang.Object)">subscribe</A></B>(java.lang.Object&nbsp;onNext,
          java.lang.Object&nbsp;onError,
          java.lang.Object&nbsp;onComplete)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#subscribe(rx.Observer)">subscribe</A></B>(<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Observer must call a Observable's <code>subscribe</code> method in order to register itself
 to receive push-based notifications from the Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#synchronize(rx.Observable)">synchronize</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;observable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accepts a Observable and wraps it in another Observable that ensures that the resulting
 Observable is chronologically well-behaved.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#take(int)">take</A></B>(int&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that emits the first <code>num</code> items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#take(rx.Observable, int)">take</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;items,
     int&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that emits the first <code>num</code> items emitted by the source
 Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toList()">toList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that emits a single item, a list composed of all the items emitted by
 the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toList(rx.Observable)">toList</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that emits a single item, a list composed of all the items emitted by
 the source Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toObservable(java.util.concurrent.Future)">toObservable</A></B>(java.util.concurrent.Future&lt;T&gt;&nbsp;future)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Future to a Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toObservable(java.util.concurrent.Future, long, java.util.concurrent.TimeUnit)">toObservable</A></B>(java.util.concurrent.Future&lt;T&gt;&nbsp;future,
             long&nbsp;time,
             java.util.concurrent.TimeUnit&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Future to a Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toObservable(java.lang.Iterable)">toObservable</A></B>(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Iterable sequence to a Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toObservable(T...)">toObservable</A></B>(T...&nbsp;items)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an Array sequence to a Observable sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList()">toSortedList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort T objects by their natural order (object must implement Comparable).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList(rx.util.functions.Func2)">toSortedList</A></B>(<A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Integer&gt;&nbsp;sortFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort T objects using the defined sort function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList(java.lang.Object)">toSortedList</A></B>(java.lang.Object&nbsp;sortFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort T objects using the defined sort function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList(rx.Observable)">toSortedList</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort T objects by their natural order (object must implement Comparable).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList(rx.Observable, rx.util.functions.Func2)">toSortedList</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
             <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,java.lang.Integer&gt;&nbsp;sortFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort T objects using the defined sort function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#toSortedList(rx.Observable, java.lang.Object)">toSortedList</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
             java.lang.Object&nbsp;sortFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort T objects using the defined sort function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T0,T1&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.util.functions.Func2)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
    <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T0,T1,R&gt;&nbsp;reduceFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by two other Observables, with the results of this closure becoming the
 sequence emitted by the returned Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T0,T1&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, java.lang.Object)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
    java.lang.Object&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by two other Observables, with the results of this closure becoming the
 sequence emitted by the returned Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T0,T1,T2&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.util.functions.Func3)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
    <A HREF="../rx/util/functions/Func3.html" title="interface in rx.util.functions">Func3</A>&lt;T0,T1,T2,R&gt;&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by three other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T0,T1,T2&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, java.lang.Object)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
    java.lang.Object&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by three other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T0,T1,T2,T3&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.util.functions.Func4)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T3&gt;&nbsp;w3,
    <A HREF="../rx/util/functions/Func4.html" title="interface in rx.util.functions">Func4</A>&lt;T0,T1,T2,T3,R&gt;&nbsp;reduceFunction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by four other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;R,T0,T1,T2,T3&gt; 
<BR>
<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../rx/Observable.html#zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, java.lang.Object)">zip</A></B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
    <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T3&gt;&nbsp;w3,
    java.lang.Object&nbsp;function)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by four other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Observable(rx.util.functions.Func1)"><!-- --></A><H3>
Observable</H3>
<PRE>
protected <B>Observable</B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;,<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A>&gt;&nbsp;onSubscribe)</PRE>
<DL>
</DL>
<HR>

<A NAME="Observable()"><!-- --></A><H3>
Observable</H3>
<PRE>
protected <B>Observable</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="subscribe(rx.Observer)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;observer)</PRE>
<DL>
<DD>A Observer must call a Observable's <code>subscribe</code> method in order to register itself
 to receive push-based notifications from the Observable. A typical implementation of the
 <code>subscribe</code> method does the following:
 
 It stores a reference to the Observer in a collection object, such as a <code>List<T></code>
 object.
 
 It returns a reference to an <code>ObservableSubscription</code> interface. This enables
 Observers to unsubscribe (that is, to stop receiving notifications) before the Observable has
 finished sending them and has called the Observer's <code>OnCompleted</code> method.
 
 At any given time, a particular instance of an <code>Observable<T></code> implementation is
 responsible for accepting all subscriptions and notifying all subscribers. Unless the
 documentation for a particular <code>Observable<T></code> implementation indicates otherwise,
 Observers should make no assumptions about the <code>Observable<T></code> implementation, such
 as the order of notifications that multiple Observers will receive.
 <p>
 For more information see
 <a href="https://confluence.corp.netflix.com/display/API/Observers%2C+Observables%2C+and+the+Reactive+Pattern">API.Next Programmer's Guide: Observers, Observables, and the Reactive Pattern</a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Observer</CODE> - 
<DT><B>Returns:</B><DD>a <code>ObservableSubscription</code> reference to an interface that allows observers
         to stop receiving notifications before the provider has finished sending them</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(java.util.Map)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(java.util.Map&lt;java.lang.String,java.lang.Object&gt;&nbsp;callbacks)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(java.lang.Object)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(java.lang.Object&nbsp;o)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.util.functions.Action1)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(java.lang.Object&nbsp;onNext,
                              java.lang.Object&nbsp;onError)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.util.functions.Action1, rx.util.functions.Action1)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
                              <A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;java.lang.Exception&gt;&nbsp;onError)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(java.lang.Object&nbsp;onNext,
                              java.lang.Object&nbsp;onError,
                              java.lang.Object&nbsp;onComplete)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subscribe(rx.util.functions.Action1, rx.util.functions.Action1, rx.util.functions.Action0)"><!-- --></A><H3>
subscribe</H3>
<PRE>
public <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>subscribe</B>(<A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;onNext,
                              <A HREF="../rx/util/functions/Action1.html" title="interface in rx.util.functions">Action1</A>&lt;java.lang.Exception&gt;&nbsp;onError,
                              <A HREF="../rx/util/functions/Action0.html" title="interface in rx.util.functions">Action0</A>&nbsp;onComplete)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(rx.util.functions.Func1)"><!-- --></A><H3>
create</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>create</B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observer.html" title="interface in rx">Observer</A>&lt;T&gt;,<A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A>&gt;&nbsp;func)</PRE>
<DL>
<DD>Creates a Observable that will execute the given function when a Observer subscribes to it.
 <p>
 You can create a simple Observable from scratch by using the <code>create</code> method. You pass this method a closure that accepts as a parameter the map of closures that a Observer passes to
 a
 Observable's <code>subscribe</code> method. Write
 the closure you pass to <code>create</code> so that it behaves as a Observable - calling the passed-in <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods
 appropriately.
 <p>
 A well-formed Observable must call either the Observer's <code>onCompleted</code> method exactly once or its <code>onError</code> method exactly once.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type emitted by the Observable sequence<DT><B>Parameters:</B><DD><CODE>func</CODE> - a closure that accepts a <code>Observer<T></code> and calls its <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods
            as appropriate, and returns a <code>ObservableSubscription</code> to allow
            cancelling the subscription (if applicable)
<DT><B>Returns:</B><DD>a Observable that, when a Observer subscribes to it, will execute the given function</DL>
</DD>
</DL>
<HR>

<A NAME="create(java.lang.Object)"><!-- --></A><H3>
create</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>create</B>(java.lang.Object&nbsp;callback)</PRE>
<DL>
<DD>Creates a Observable that will execute the given function when a Observer subscribes to it.
 <p>
 You can create a simple Observable from scratch by using the <code>create</code> method. You pass this method a closure that accepts as a parameter the map of closures that a Observer passes to
 a
 Observable's <code>subscribe</code> method. Write
 the closure you pass to <code>create</code> so that it behaves as a Observable - calling the passed-in <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods
 appropriately.
 <p>
 A well-formed Observable must call either the Observer's <code>onCompleted</code> method exactly once or its <code>onError</code> method exactly once.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the observable sequence<DT><B>Parameters:</B><DD><CODE>func</CODE> - a closure that accepts a <code>Observer<T></code> and calls its <code>onNext</code>, <code>onError</code>, and <code>onCompleted</code> methods
            as appropriate, and returns a <code>ObservableSubscription</code> to allow
            cancelling the subscription (if applicable)
<DT><B>Returns:</B><DD>a Observable that, when a Observer subscribes to it, will execute the given function</DL>
</DD>
</DL>
<HR>

<A NAME="empty()"><!-- --></A><H3>
empty</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>empty</B>()</PRE>
<DL>
<DD>Returns a Observable that returns no data to the Observer and immediately invokes its <code>onCompleted</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.empty&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.empty.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of item emitted by the Observable
<DT><B>Returns:</B><DD>a Observable that returns no data to the Observer and immediately invokes the
         Observer's <code>onCompleted</code> method</DL>
</DD>
</DL>
<HR>

<A NAME="error(java.lang.Exception)"><!-- --></A><H3>
error</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>error</B>(java.lang.Exception&nbsp;exception)</PRE>
<DL>
<DD>Returns a Observable that calls <code>onError</code> when a Observer subscribes to it.
 <p>
 Note: Maps to <code>Observable.Throw</code> in Rx - throw is a reserved word in Java.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.error&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.error.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of object returned by the Observable<DT><B>Parameters:</B><DD><CODE>exception</CODE> - the error to throw
<DT><B>Returns:</B><DD>a Observable object that calls <code>onError</code> when a Observer subscribes</DL>
</DD>
</DL>
<HR>

<A NAME="filter(rx.Observable, rx.util.functions.Func1)"><!-- --></A><H3>
filter</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>filter</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                                       <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;T,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Filters a Observable by discarding any of its emissions that do not meet some test.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.filter&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.filter.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the Observable to filter<DD><CODE>predicate</CODE> - a closure that evaluates the items emitted by the source Observable, returning <code>true</code> if they pass the filter
<DT><B>Returns:</B><DD>a Observable that emits only those items in the original Observable that the filter
         evaluates as true</DL>
</DD>
</DL>
<HR>

<A NAME="filter(rx.Observable, java.lang.Object)"><!-- --></A><H3>
filter</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>filter</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                                       java.lang.Object&nbsp;function)</PRE>
<DL>
<DD>Filters a Observable by discarding any of its emissions that do not meet some test.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.filter&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.filter.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the Observable to filter<DD><CODE>predicate</CODE> - a closure that evaluates the items emitted by the source Observable, returning <code>true</code> if they pass the filter
<DT><B>Returns:</B><DD>a Observable that emits only those items in the original Observable that the filter
         evaluates as true</DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Iterable)"><!-- --></A><H3>
from</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</PRE>
<DL>
<DD>Converts an Iterable sequence to a Observable sequence.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the iterable sequence and the type emitted by the resulting
            Observable<DT><B>Parameters:</B><DD><CODE>iterable</CODE> - the source Iterable sequence
<DT><B>Returns:</B><DD>a Observable that emits each item in the source Iterable sequence<DT><B>See Also:</B><DD><CODE>#toObservable(Iterable)}</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="from(java.lang.Object[])"><!-- --></A><A NAME="from(T...)"><!-- --></A><H3>
from</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>from</B>(T...&nbsp;items)</PRE>
<DL>
<DD>Converts an Array sequence to a Observable sequence.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the Array, and the type of items emitted by the resulting
            Observable<DT><B>Parameters:</B><DD><CODE>iterable</CODE> - the source Array
<DT><B>Returns:</B><DD>a Observable that emits each item in the source Array<DT><B>See Also:</B><DD><CODE>#toObservable(Object...)}</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="just(java.lang.Object)"><!-- --></A><A NAME="just(T)"><!-- --></A><H3>
just</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>just</B>(T&nbsp;value)</PRE>
<DL>
<DD>Returns a Observable that notifies an observer of a single value and then completes.
 <p>
 To convert any object into a Observable that emits that object, pass that object into the <code>just</code> method.
 <p>
 This is similar to the <CODE>toObservable</CODE> method, except that <code>toObservable</code> will convert an iterable object into a Observable that emits each of the items in the iterable, one at
 a
 time, while the <code>just</code> method would
 convert the iterable into a Observable that emits the entire iterable as a single item.
 <p>
 This value is the equivalent of <code>Observable.Return</code> in the Reactive Extensions library.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.just&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.just.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of the value<DT><B>Parameters:</B><DD><CODE>value</CODE> - the value to pass to the Observer's <code>onNext</code> method
<DT><B>Returns:</B><DD>a Observable that notifies a Observer of a single value and then completes</DL>
</DD>
</DL>
<HR>

<A NAME="last(rx.Observable)"><!-- --></A><H3>
last</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>last</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that)</PRE>
<DL>
<DD>Takes the last item emitted by a source Observable and returns a Observable that emits only
 that item as its sole emission.
 <p>
 To convert a Observable that emits a sequence of objects into one that only emits the last object in this sequence before completing, use the <code>last</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.last&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.last.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the source Observable
<DT><B>Returns:</B><DD>a Observable that emits a single item, which is identical to the last item emitted
         by the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="map(rx.Observable, rx.util.functions.Func1)"><!-- --></A><H3>
map</H3>
<PRE>
public static &lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>map</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                      <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;T,R&gt;&nbsp;func)</PRE>
<DL>
<DD>Applies a closure of your choosing to every notification emitted by a Observable, and returns
 this transformation as a new Observable sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.map&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.map.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items emitted by the the source Observable<DD><CODE>R</CODE> - the type of items returned by map closure <code>func</code><DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>func</CODE> - a closure to apply to each item in the sequence emitted by the source Observable
<DT><B>Returns:</B><DD>a Observable that is the result of applying the transformation function to each item
         in the sequence emitted by the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="map(rx.Observable, java.lang.Object)"><!-- --></A><H3>
map</H3>
<PRE>
public static &lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>map</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                      java.lang.Object&nbsp;function)</PRE>
<DL>
<DD>Applies a closure of your choosing to every notification emitted by a Observable, and returns
 this transformation as a new Observable sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.map&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.map.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items emitted by the the source Observable<DD><CODE>R</CODE> - the type of items returned by map closure <code>function</code><DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>function</CODE> - a closure to apply to each item in the sequence emitted by the source Observable
<DT><B>Returns:</B><DD>a Observable that is the result of applying the transformation function to each item
         in the sequence emitted by the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="mapMany(rx.Observable, rx.util.functions.Func1)"><!-- --></A><H3>
mapMany</H3>
<PRE>
public static &lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mapMany</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                          <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;T,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;func)</PRE>
<DL>
<DD>Creates a new Observable sequence by applying a closure that you supply to each object in the
 original Observable sequence, where that closure is itself a Observable that emits objects,
 and then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.mapmany&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.mapMany.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type emitted by the source Observable<DD><CODE>R</CODE> - the type emitted by the Observables emitted by <code>func</code><DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>func</CODE> - a closure to apply to each item emitted by the source Observable, generating a
            Observable
<DT><B>Returns:</B><DD>a Observable that emits a sequence that is the result of applying the transformation
         function to each item emitted by the source Observable and merging the results of
         the Observables obtained from this transformation</DL>
</DD>
</DL>
<HR>

<A NAME="mapMany(rx.Observable, java.lang.Object)"><!-- --></A><H3>
mapMany</H3>
<PRE>
public static &lt;T,R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mapMany</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                          java.lang.Object&nbsp;function)</PRE>
<DL>
<DD>Creates a new Observable sequence by applying a closure that you supply to each object in the
 original Observable sequence, where that closure is itself a Observable that emits objects,
 and then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.mapmany&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.mapMany.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type emitted by the source Observable<DD><CODE>R</CODE> - the type emitted by the Observables emitted by <code>function</code><DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>function</CODE> - a closure to apply to each item emitted by the source Observable, generating a
            Observable
<DT><B>Returns:</B><DD>a Observable that emits a sequence that is the result of applying the transformation
         function to each item emitted by the source Observable and merging the results of the
         Observables obtained from this transformation</DL>
</DD>
</DL>
<HR>

<A NAME="materialize(rx.Observable)"><!-- --></A><H3>
materialize</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;T&gt;&gt; <B>materialize</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence)</PRE>
<DL>
<DD>Materializes the implicit notifications of an observable sequence as explicit notification values.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.materialize&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.materialize.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - An observable sequence of elements to project.
<DT><B>Returns:</B><DD>An observable sequence whose elements are the result of materializing the notifications of the given sequence.<DT><B>See Also:</B><DD><CODE>http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="merge(java.util.List)"><!-- --></A><H3>
merge</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(java.util.List&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</PRE>
<DL>
<DD>Flattens the Observable sequences from a list of Observables into one Observable sequence
 without any transformation. You can combine the output of multiple Observables so that they
 act like a single Observable, by using the <code>merge</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.merge&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.merge.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a list of Observables that emit sequences of items
<DT><B>Returns:</B><DD>a Observable that emits a sequence of elements that are the result of flattening the
         output from the <code>source</code> list of Observables<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable)"><!-- --></A><H3>
merge</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</PRE>
<DL>
<DD>Flattens the Observable sequences emitted by a sequence of Observables that are emitted by a
 Observable into one Observable sequence without any transformation. You can combine the output
 of multiple Observables so that they act like a single Observable, by using the <code>merge</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.merge.W&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.merge.W.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a Observable that emits Observables
<DT><B>Returns:</B><DD>a Observable that emits a sequence of elements that are the result of flattening the
         output from the Observables emitted by the <code>source</code> Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="merge(rx.Observable...)"><!-- --></A><H3>
merge</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>merge</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;...&nbsp;source)</PRE>
<DL>
<DD>Flattens the Observable sequences from a series of Observables into one Observable sequence
 without any transformation. You can combine the output of multiple Observables so that they
 act like a single Observable, by using the <code>merge</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.merge&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.merge.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a series of Observables that emit sequences of items
<DT><B>Returns:</B><DD>a Observable that emits a sequence of elements that are the result of flattening the
         output from the <code>source</code> Observables<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="concat(rx.Observable...)"><!-- --></A><H3>
concat</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>concat</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;...&nbsp;source)</PRE>
<DL>
<DD>Combines the objects emitted by two or more Observables, and emits the result as a single Observable,
 by using the <code>concat</code> method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a series of Observables that emit sequences of items
<DT><B>Returns:</B><DD>a Observable that emits a sequence of elements that are the result of combining the
         output from the <code>source</code> Observables<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat(v=vs.103).aspx">MSDN: Observable.Concat Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(java.util.List)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(java.util.List&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</PRE>
<DL>
<DD>Same functionality as <code>merge</code> except that errors received to onError will be held until all sequences have finished (onComplete/onError) before sending the error.
 <p>
 Only the first onError received will be sent.
 <p>
 This enables receiving all successes from merged sequences without one onError from one sequence causing all onNext calls to be prevented.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.mergeDelayError&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.mergeDelayError.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a list of Observables that emit sequences of items
<DT><B>Returns:</B><DD>a Observable that emits a sequence of elements that are the result of flattening the
         output from the <code>source</code> list of Observables<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;source)</PRE>
<DL>
<DD>Same functionality as <code>merge</code> except that errors received to onError will be held until all sequences have finished (onComplete/onError) before sending the error.
 <p>
 Only the first onError received will be sent.
 <p>
 This enables receiving all successes from merged sequences without one onError from one sequence causing all onNext calls to be prevented.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.mergeDelayError.W&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.mergeDelayError.W.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a Observable that emits Observables
<DT><B>Returns:</B><DD>a Observable that emits a sequence of elements that are the result of flattening the
         output from the Observables emitted by the <code>source</code> Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="mergeDelayError(rx.Observable...)"><!-- --></A><H3>
mergeDelayError</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>mergeDelayError</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;...&nbsp;source)</PRE>
<DL>
<DD>Same functionality as <code>merge</code> except that errors received to onError will be held until all sequences have finished (onComplete/onError) before sending the error.
 <p>
 Only the first onError received will be sent.
 <p>
 This enables receiving all successes from merged sequences without one onError from one sequence causing all onNext calls to be prevented.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.mergeDelayError&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.mergeDelayError.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a series of Observables that emit sequences of items
<DT><B>Returns:</B><DD>a Observable that emits a sequence of elements that are the result of flattening the
         output from the <code>source</code> Observables<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229099(v=vs.103).aspx">MSDN: Observable.Merge Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="never()"><!-- --></A><H3>
never</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>never</B>()</PRE>
<DL>
<DD>Returns a Observable that never sends any information to a Observer.
 
 This observable is useful primarily for testing purposes.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.never&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.never.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of item (not) emitted by the Observable
<DT><B>Returns:</B><DD>a Observable that never sends any information to a Observer</DL>
</DD>
</DL>
<HR>

<A NAME="noOpSubscription()"><!-- --></A><H3>
noOpSubscription</H3>
<PRE>
public static <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>noOpSubscription</B>()</PRE>
<DL>
<DD>A ObservableSubscription that does nothing.
 
 //TODO should this be moved to a Subscriptions utility class?
<P>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="createSubscription(rx.util.functions.Action0)"><!-- --></A><H3>
createSubscription</H3>
<PRE>
public static <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>createSubscription</B>(<A HREF="../rx/util/functions/Action0.html" title="interface in rx.util.functions">Action0</A>&nbsp;unsubscribe)</PRE>
<DL>
<DD>A Subscription implemented via a Func
 
 //TODO should this be moved to a Subscriptions utility class?
<P>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="createSubscription(java.lang.Object)"><!-- --></A><H3>
createSubscription</H3>
<PRE>
public static <A HREF="../rx/Subscription.html" title="interface in rx">Subscription</A> <B>createSubscription</B>(java.lang.Object&nbsp;unsubscribe)</PRE>
<DL>
<DD>A Subscription implemented via an anonymous function (such as closures from other languages).
 
 //TODO should this be moved to a Subscriptions utility class?
<P>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(rx.Observable, rx.util.functions.Func1)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>onErrorResumeNext</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                                                  <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&gt;&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instruct a Observable to pass control to another Observable (the return value of a function)
 rather than calling <code>onError</code> if it encounters an error.
 <p>
 By default, when a Observable encounters an error that prevents it from emitting the expected item to its Observer, the Observable calls its Observer's <code>onError</code> closure, and then
 quits
 without calling any more of its Observer's
 closures. The <code>onErrorResumeNext</code> method changes this behavior. If you pass a closure that emits a Observable (<code>resumeFunction</code>) to a Observable's
 <code>onErrorResumeNext</code> method, if the original Observable encounters
 an error, instead of calling its Observer's <code>onError</code> closure, it will instead relinquish control to this new Observable, which will call the Observer's <code>onNext</code> method if
 it
 is able to do so. In such a case, because no
 Observable necessarily invokes <code>onError</code>, the Observer may never know that an error happened.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorresumenext&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorresumenext.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the source Observable<DD><CODE>resumeFunction</CODE> - a closure that returns a Observable that will take over if the source Observable
            encounters an error
<DT><B>Returns:</B><DD>the source Observable, with its behavior modified as described</DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(rx.Observable, java.lang.Object)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>onErrorResumeNext</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                                                  java.lang.Object&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instruct a Observable to emit a particular object (as returned by a closure) to its Observer
 rather than calling <code>onError</code> if it encounters an error.
 <p>
 By default, when a Observable encounters an error that prevents it from emitting the expected item to its Observer, the Observable calls its Observer's <code>onError</code> closure, and then
 quits
 without calling any more of its Observer's
 closures. The <code>onErrorResumeNext</code> method changes this behavior. If you pass a function that returns another Observable (<code>resumeFunction</code>) to a Observable's
 <code>onErrorResumeNext</code> method, if the original Observable
 encounters an error, instead of calling its Observer's <code>onError</code> closure, it will instead relinquish control to this new Observable which will call the Observer's <code>onNext</code>
 method if it is able to do so. In such a case,
 because no Observable necessarily invokes <code>onError</code>, the Observer may never know that an error happened.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorresumenext&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorresumenext.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the source Observable<DD><CODE>resumeFunction</CODE> - a closure that returns a Observable that will take over if the source Observable
            encounters an error
<DT><B>Returns:</B><DD>the source Observable, with its behavior modified as described</DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(rx.Observable, rx.Observable)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>onErrorResumeNext</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                                                  <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;resumeSequence)</PRE>
<DL>
<DD>Instruct a Observable to pass control to another Observable rather than calling <code>onError</code> if it encounters an error.
 <p>
 By default, when a Observable encounters an error that prevents it from emitting the expected item to its Observer, the Observable calls its Observer's <code>onError</code> closure, and then
 quits
 without calling any more of its Observer's
 closures. The <code>onErrorResumeNext</code> method changes this behavior. If you pass another Observable (<code>resumeSequence</code>) to a Observable's <code>onErrorResumeNext</code> method,
 if
 the original Observable encounters an error,
 instead of calling its Observer's <code>onError</code> closure, it will instead relinquish control to <code>resumeSequence</code> which will call the Observer's <code>onNext</code> method if it
 is able to do so. In such a case, because no
 Observable necessarily invokes <code>onError</code>, the Observer may never know that an error happened.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorresumenext&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorresumenext.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the source Observable<DD><CODE>resumeSequence</CODE> - the Observable that will take over if the source Observable encounters an error
<DT><B>Returns:</B><DD>the source Observable, with its behavior modified as described</DL>
</DD>
</DL>
<HR>

<A NAME="onErrorReturn(rx.Observable, rx.util.functions.Func1)"><!-- --></A><H3>
onErrorReturn</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>onErrorReturn</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that,
                                              <A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,T&gt;&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instruct a Observable to emit a particular item to its Observer's <code>onNext</code> closure
 rather than calling <code>onError</code> if it encounters an error.
 <p>
 By default, when a Observable encounters an error that prevents it from emitting the expected item to its Observer, the Observable calls its Observer's <code>onError</code> closure, and then
 quits
 without calling any more of its Observer's
 closures. The <code>onErrorReturn</code> method changes this behavior. If you pass a closure (<code>resumeFunction</code>) to a Observable's <code>onErrorReturn</code> method, if the original
 Observable encounters an error, instead of calling
 its Observer's <code>onError</code> closure, it will instead pass the return value of <code>resumeFunction</code> to the Observer's <code>onNext</code> method.
 <p>
 You can use this to prevent errors from propagating or to supply fallback data should errors be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorreturn&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorreturn.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the source Observable<DD><CODE>resumeFunction</CODE> - a closure that returns a value that will be passed into a Observer's <code>onNext</code> closure if the Observable encounters an error that would
            otherwise cause it to call <code>onError</code>
<DT><B>Returns:</B><DD>the source Observable, with its behavior modified as described</DL>
</DD>
</DL>
<HR>

<A NAME="reduce(rx.Observable, rx.util.functions.Func2)"><!-- --></A><H3>
reduce</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>reduce</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                       <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate," "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code>
 method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce.noseed&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.noseed.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a single element that is the result of accumulating the
         output from applying the accumulator to the sequence of items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="reduce(rx.Observable, java.lang.Object)"><!-- --></A><H3>
reduce</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>reduce</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                       java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate," "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code>
 method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce.noseed&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.noseed.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a single element that is the result of accumulating the
         output from applying the accumulator to the sequence of items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="reduce(rx.Observable,java.lang.Object,rx.util.functions.Func2)"><!-- --></A><A NAME="reduce(rx.Observable, T, rx.util.functions.Func2)"><!-- --></A><H3>
reduce</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>reduce</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                       T&nbsp;initialValue,
                                       <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate," "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code>
 method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>initialValue</CODE> - a seed passed into the first execution of the accumulator closure<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a single element that is the result of accumulating the
         output from applying the accumulator to the sequence of items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="reduce(rx.Observable,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="reduce(rx.Observable, T, java.lang.Object)"><!-- --></A><H3>
reduce</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>reduce</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                       T&nbsp;initialValue,
                                       java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate," "compress," or "inject" in other programming contexts. Groovy, for instance, has an <code>inject</code>
 method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>initialValue</CODE> - a seed passed into the first execution of the accumulator closure<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a single element that is the result of accumulating the
         output from applying the accumulator to the sequence of items emitted by the source
         Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(rx.Observable, rx.util.functions.Func2)"><!-- --></A><H3>
scan</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>scan</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                     <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.scan.noseed&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.noseed.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be emitted and used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a sequence of items that are the result of accumulating the
         output from the sequence emitted by the source Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(rx.Observable, java.lang.Object)"><!-- --></A><H3>
scan</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>scan</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                     java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.scan.noseed&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.noseed.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be emitted and used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a sequence of items that are the result of accumulating the
         output from the sequence emitted by the source Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(rx.Observable,java.lang.Object,rx.util.functions.Func2)"><!-- --></A><A NAME="scan(rx.Observable, T, rx.util.functions.Func2)"><!-- --></A><H3>
scan</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>scan</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                     T&nbsp;initialValue,
                                     <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,T&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.scan&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>initialValue</CODE> - the initial (seed) accumulator value<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be emitted and used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a sequence of items that are the result of accumulating the
         output from the sequence emitted by the source Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(rx.Observable,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="scan(rx.Observable, T, java.lang.Object)"><!-- --></A><H3>
scan</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>scan</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                     T&nbsp;initialValue,
                                     java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.scan&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - the source Observable<DD><CODE>initialValue</CODE> - the initial (seed) accumulator value<DD><CODE>accumulator</CODE> - an accumulator closure to be invoked on each element from the sequence, whose
            result will be emitted and used in the next accumulator call (if applicable)
<DT><B>Returns:</B><DD>a Observable that emits a sequence of items that are the result of accumulating the
         output from the sequence emitted by the source Observable<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="skip(rx.Observable, int)"><!-- --></A><H3>
skip</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>skip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;items,
                                     int&nbsp;num)</PRE>
<DL>
<DD>Returns a Observable that skips the first <code>num</code> items emitted by the source
 Observable. You can ignore the first <code>num</code> items emitted by a Observable and attend
 only to those items that come after, by modifying the Observable with the <code>skip</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.skip&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.skip.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>items</CODE> - the source Observable<DD><CODE>num</CODE> - the number of items to skip
<DT><B>Returns:</B><DD>a Observable that emits the same sequence of items emitted by the source Observable,
         except for the first <code>num</code> items<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229847(v=vs.103).aspx">MSDN: Observable.Skip Method</a></DL>
</DD>
</DL>
<HR>

<A NAME="synchronize(rx.Observable)"><!-- --></A><H3>
synchronize</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>synchronize</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;observable)</PRE>
<DL>
<DD>Accepts a Observable and wraps it in another Observable that ensures that the resulting
 Observable is chronologically well-behaved.
 <p>
 A well-behaved observable ensures <code>onNext</code>, <code>onCompleted</code>, or <code>onError</code> calls to its subscribers are not interleaved, <code>onCompleted</code> and
 <code>onError</code> are only called once respectively, and no
 <code>onNext</code> calls follow <code>onCompleted</code> and <code>onError</code> calls.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of item emitted by the source Observable<DT><B>Parameters:</B><DD><CODE>observable</CODE> - the source Observable
<DT><B>Returns:</B><DD>a Observable that is a chronologically well-behaved version of the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="take(rx.Observable, int)"><!-- --></A><H3>
take</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>take</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;items,
                                     int&nbsp;num)</PRE>
<DL>
<DD>Returns a Observable that emits the first <code>num</code> items emitted by the source
 Observable.
 <p>
 You can choose to pay attention only to the first <code>num</code> values emitted by a Observable by calling its <code>take</code> method. This method returns a Observable that will call a
 subscribing Observer's <code>onNext</code> closure a
 maximum of <code>num</code> times before calling <code>onCompleted</code>.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.take&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.take.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>items</CODE> - the source Observable<DD><CODE>num</CODE> - the number of items from the start of the sequence emitted by the source
            Observable to emit
<DT><B>Returns:</B><DD>a Observable that only emits the first <code>num</code> items emitted by the source
         Observable</DL>
</DD>
</DL>
<HR>

<A NAME="toList(rx.Observable)"><!-- --></A><H3>
toList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt; <B>toList</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;that)</PRE>
<DL>
<DD>Returns a Observable that emits a single item, a list composed of all the items emitted by
 the source Observable.
 <p>
 Normally, a Observable that returns multiple items will do so by calling its Observer's <code>onNext</code> closure for each such item. You can change this behavior, instructing the Observable
 to
 compose a list of all of these multiple items and
 then to call the Observer's <code>onNext</code> closure once, passing it the entire list, by calling the Observable object's <code>toList</code> method prior to calling its
 <code>subscribe</code>
 method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolist&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolist.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - the source Observable
<DT><B>Returns:</B><DD>a Observable that emits a single item: a <code>List</code> containing all of the
         items emitted by the source Observable</DL>
</DD>
</DL>
<HR>

<A NAME="toObservable(java.lang.Iterable)"><!-- --></A><H3>
toObservable</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>toObservable</B>(java.lang.Iterable&lt;T&gt;&nbsp;iterable)</PRE>
<DL>
<DD>Converts an Iterable sequence to a Observable sequence.
 
 Any object that supports the Iterable interface can be converted into a Observable that emits
 each iterable item in the object, by passing the object into the <code>toObservable</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.toObservable&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.toObservable.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the iterable sequence and the type emitted by the resulting
            Observable<DT><B>Parameters:</B><DD><CODE>iterable</CODE> - the source Iterable sequence
<DT><B>Returns:</B><DD>a Observable that emits each item in the source Iterable sequence</DL>
</DD>
</DL>
<HR>

<A NAME="toObservable(java.util.concurrent.Future)"><!-- --></A><H3>
toObservable</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>toObservable</B>(java.util.concurrent.Future&lt;T&gt;&nbsp;future)</PRE>
<DL>
<DD>Converts an Future to a Observable sequence.
 
 Any object that supports the <CODE>Future</CODE> interface can be converted into a Observable that emits
 the return value of the get() method in the object, by passing the object into the <code>toObservable</code> method.
 The subscribe method on this synchronously so the Subscription returned doesn't nothing.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of of object that the future's returns and the type emitted by the resulting
            Observable<DT><B>Parameters:</B><DD><CODE>future</CODE> - the source <CODE>Future</CODE>
<DT><B>Returns:</B><DD>a Observable that emits the item from the source Future</DL>
</DD>
</DL>
<HR>

<A NAME="toObservable(java.util.concurrent.Future, long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
toObservable</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>toObservable</B>(java.util.concurrent.Future&lt;T&gt;&nbsp;future,
                                             long&nbsp;time,
                                             java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL>
<DD>Converts an Future to a Observable sequence.
 
 Any object that supports the <CODE>Future</CODE> interface can be converted into a Observable that emits
 the return value of the get() method in the object, by passing the object into the <code>toObservable</code> method.
 The subscribe method on this synchronously so the Subscription returned doesn't nothing.
 If the future timesout the <CODE>TimeoutException</CODE> exception is passed to the onError.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of of object that the future's returns and the type emitted by the resulting
            Observable<DT><B>Parameters:</B><DD><CODE>future</CODE> - the source <CODE>Future</CODE><DD><CODE>time</CODE> - the maximum time to wait<DD><CODE>unit</CODE> - the time unit of the time argument
<DT><B>Returns:</B><DD>a Observable that emits the item from the source Future</DL>
</DD>
</DL>
<HR>

<A NAME="toObservable(java.lang.Object[])"><!-- --></A><A NAME="toObservable(T...)"><!-- --></A><H3>
toObservable</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt; <B>toObservable</B>(T...&nbsp;items)</PRE>
<DL>
<DD>Converts an Array sequence to a Observable sequence.
 
 An Array can be converted into a Observable that emits each item in the Array, by passing the
 Array into the <code>toObservable</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.toObservable&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.toObservable.png"></a>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - the type of items in the Array, and the type of items emitted by the resulting
            Observable<DT><B>Parameters:</B><DD><CODE>iterable</CODE> - the source Array
<DT><B>Returns:</B><DD>a Observable that emits each item in the source Array</DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList(rx.Observable)"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt; <B>toSortedList</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence)</PRE>
<DL>
<DD>Sort T objects by their natural order (object must implement Comparable).
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolistsorted&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolistsorted.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - 
<DT><B>Returns:</B><DD>
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if T objects do not implement Comparable</DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList(rx.Observable, rx.util.functions.Func2)"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt; <B>toSortedList</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                                             <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T,T,java.lang.Integer&gt;&nbsp;sortFunction)</PRE>
<DL>
<DD>Sort T objects using the defined sort function.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolistsorted.f&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolistsorted.f.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - <DD><CODE>sortFunction</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList(rx.Observable, java.lang.Object)"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;T&gt;&gt; <B>toSortedList</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T&gt;&nbsp;sequence,
                                                             java.lang.Object&nbsp;sortFunction)</PRE>
<DL>
<DD>Sort T objects using the defined sort function.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolistsorted.f&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolistsorted.f.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sequence</CODE> - <DD><CODE>sortFunction</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.util.functions.Func2)"><!-- --></A><H3>
zip</H3>
<PRE>
public static &lt;R,T0,T1&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
                                          <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;T0,T1,R&gt;&nbsp;reduceFunction)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by two other Observables, with the results of this closure becoming the
 sequence emitted by the returned Observable.
 <p>
 <code>zip</code> applies this closure in strict sequence, so the first item emitted by the new Observable will be the result of the closure applied to the first item emitted by <code>w0</code>
 and the first item emitted by <code>w1</code>; the
 second item emitted by the new Observable will be the result of the closure applied to the second item emitted by <code>w0</code> and the second item emitted by <code>w1</code>; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will call <code>onNext</code> as many times as the number <code>onNext</code> calls of the source Observable with the
 shortest sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.zip&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.zip.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w0</CODE> - one source Observable<DD><CODE>w1</CODE> - another source Observable<DD><CODE>reduceFunction</CODE> - a closure that, when applied to an item emitted by each of the source Observables,
            results in a value that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>a Observable that emits the zipped results</DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, java.lang.Object)"><!-- --></A><H3>
zip</H3>
<PRE>
public static &lt;R,T0,T1&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
                                          <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
                                          java.lang.Object&nbsp;function)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by two other Observables, with the results of this closure becoming the
 sequence emitted by the returned Observable.
 <p>
 <code>zip</code> applies this closure in strict sequence, so the first item emitted by the new Observable will be the result of the closure applied to the first item emitted by <code>w0</code>
 and the first item emitted by <code>w1</code>; the
 second item emitted by the new Observable will be the result of the closure applied to the second item emitted by <code>w0</code> and the second item emitted by <code>w1</code>; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will call <code>onNext</code> as many times as the number <code>onNext</code> calls of the source Observable with the
 shortest sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.zip&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.zip.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w0</CODE> - one source Observable<DD><CODE>w1</CODE> - another source Observable<DD><CODE>reduceFunction</CODE> - a closure that, when applied to an item emitted by each of the source Observables,
            results in a value that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>a Observable that emits the zipped results</DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.util.functions.Func3)"><!-- --></A><H3>
zip</H3>
<PRE>
public static &lt;R,T0,T1,T2&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
                                             <A HREF="../rx/util/functions/Func3.html" title="interface in rx.util.functions">Func3</A>&lt;T0,T1,T2,R&gt;&nbsp;function)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by three other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.
 <p>
 <code>zip</code> applies this closure in strict sequence, so the first item emitted by the new Observable will be the result of the closure applied to the first item emitted by <code>w0</code>,
 the first item emitted by <code>w1</code>, and the
 first item emitted by <code>w2</code>; the second item emitted by the new Observable will be the result of the closure applied to the second item emitted by <code>w0</code>, the second item
 emitted by <code>w1</code>, and the second item
 emitted by <code>w2</code>; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will call <code>onNext</code> as many times as the number <code>onNext</code> calls of the source Observable with the
 shortest sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.zip.3&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.zip.3.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w0</CODE> - one source Observable<DD><CODE>w1</CODE> - another source Observable<DD><CODE>w2</CODE> - a third source Observable<DD><CODE>function</CODE> - a closure that, when applied to an item emitted by each of the source Observables,
            results in a value that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>a Observable that emits the zipped results</DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, java.lang.Object)"><!-- --></A><H3>
zip</H3>
<PRE>
public static &lt;R,T0,T1,T2&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
                                             <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
                                             java.lang.Object&nbsp;function)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by three other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.
 <p>
 <code>zip</code> applies this closure in strict sequence, so the first item emitted by the new Observable will be the result of the closure applied to the first item emitted by <code>w0</code>,
 the first item emitted by <code>w1</code>, and the
 first item emitted by <code>w2</code>; the second item emitted by the new Observable will be the result of the closure applied to the second item emitted by <code>w0</code>, the second item
 emitted by <code>w1</code>, and the second item
 emitted by <code>w2</code>; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will call <code>onNext</code> as many times as the number <code>onNext</code> calls of the source Observable with the
 shortest sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.zip.3&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.zip.3.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w0</CODE> - one source Observable<DD><CODE>w1</CODE> - another source Observable<DD><CODE>w2</CODE> - a third source Observable<DD><CODE>function</CODE> - a closure that, when applied to an item emitted by each of the source Observables,
            results in a value that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>a Observable that emits the zipped results</DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, rx.util.functions.Func4)"><!-- --></A><H3>
zip</H3>
<PRE>
public static &lt;R,T0,T1,T2,T3&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T3&gt;&nbsp;w3,
                                                <A HREF="../rx/util/functions/Func4.html" title="interface in rx.util.functions">Func4</A>&lt;T0,T1,T2,T3,R&gt;&nbsp;reduceFunction)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by four other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.
 <p>
 <code>zip</code> applies this closure in strict sequence, so the first item emitted by the new Observable will be the result of the closure applied to the first item emitted by <code>w0</code>,
 the first item emitted by <code>w1</code>, the
 first item emitted by <code>w2</code>, and the first item emitted by <code>w3</code>; the second item emitted by the new Observable will be the result of the closure applied to the second item
 emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will call <code>onNext</code> as many times as the number <code>onNext</code> calls of the source Observable with the
 shortest sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.zip.4&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.zip.4.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w0</CODE> - one source Observable<DD><CODE>w1</CODE> - another source Observable<DD><CODE>w2</CODE> - a third source Observable<DD><CODE>w3</CODE> - a fourth source Observable<DD><CODE>reduceFunction</CODE> - a closure that, when applied to an item emitted by each of the source Observables,
            results in a value that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>a Observable that emits the zipped results</DL>
</DD>
</DL>
<HR>

<A NAME="zip(rx.Observable, rx.Observable, rx.Observable, rx.Observable, java.lang.Object)"><!-- --></A><H3>
zip</H3>
<PRE>
public static &lt;R,T0,T1,T2,T3&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>zip</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T0&gt;&nbsp;w0,
                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T1&gt;&nbsp;w1,
                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T2&gt;&nbsp;w2,
                                                <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;T3&gt;&nbsp;w3,
                                                java.lang.Object&nbsp;function)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the combination of items
 emitted, in sequence, by four other Observables, with the results of this closure becoming
 the sequence emitted by the returned Observable.
 <p>
 <code>zip</code> applies this closure in strict sequence, so the first item emitted by the new Observable will be the result of the closure applied to the first item emitted by <code>w0</code>,
 the first item emitted by <code>w1</code>, the
 first item emitted by <code>w2</code>, and the first item emitted by <code>w3</code>; the second item emitted by the new Observable will be the result of the closure applied to the second item
 emitted by each of those Observables; and so forth.
 <p>
 The resulting <code>Observable<R></code> returned from <code>zip</code> will call <code>onNext</code> as many times as the number <code>onNext</code> calls of the source Observable with the
 shortest sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.zip.4&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.zip.4.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w0</CODE> - one source Observable<DD><CODE>w1</CODE> - another source Observable<DD><CODE>w2</CODE> - a third source Observable<DD><CODE>w3</CODE> - a fourth source Observable<DD><CODE>function</CODE> - a closure that, when applied to an item emitted by each of the source Observables,
            results in a value that will be emitted by the resulting Observable
<DT><B>Returns:</B><DD>a Observable that emits the zipped results</DL>
</DD>
</DL>
<HR>

<A NAME="filter(rx.util.functions.Func1)"><!-- --></A><H3>
filter</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>filter</B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Boolean&gt;&nbsp;predicate)</PRE>
<DL>
<DD>Filters a Observable by discarding any of its emissions that do not meet some test.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.filter&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.filter.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>predicate</CODE> - a closure that evaluates the items emitted by the source Observable, returning
            <code>true</code> if they pass the filter
<DT><B>Returns:</B><DD>a Observable that emits only those items in the original Observable that the filter
         evaluates as <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="filter(java.lang.Object)"><!-- --></A><H3>
filter</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>filter</B>(java.lang.Object&nbsp;callback)</PRE>
<DL>
<DD>Filters a Observable by discarding any of its emissions that do not meet some test.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.filter&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.filter.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>callback</CODE> - a closure that evaluates the items emitted by the source Observable, returning
            <code>true</code> if they pass the filter
<DT><B>Returns:</B><DD>a Observable that emits only those items in the original Observable that the filter
         evaluates as "true"</DL>
</DD>
</DL>
<HR>

<A NAME="last()"><!-- --></A><H3>
last</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>last</B>()</PRE>
<DL>
<DD>Converts a Observable that emits a sequence of objects into one that only emits the last
 object in this sequence before completing.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.last&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.last.png"></a>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a Observable that emits only the last item emitted by the original Observable</DL>
</DD>
</DL>
<HR>

<A NAME="map(rx.util.functions.Func1)"><!-- --></A><H3>
map</H3>
<PRE>
public &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>map</B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,R&gt;&nbsp;func)</PRE>
<DL>
<DD>Applies a closure of your choosing to every item emitted by a Observable, and returns this
 transformation as a new Observable sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.map&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.map.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - a closure to apply to each item in the sequence.
<DT><B>Returns:</B><DD>a Observable that emits a sequence that is the result of applying the transformation
         closure to each item in the sequence emitted by the input Observable.</DL>
</DD>
</DL>
<HR>

<A NAME="map(java.lang.Object)"><!-- --></A><H3>
map</H3>
<PRE>
public &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>map</B>(java.lang.Object&nbsp;callback)</PRE>
<DL>
<DD>Applies a closure of your choosing to every item emitted by a Observable, and returns this
 transformation as a new Observable sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.map&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.map.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>callback</CODE> - a closure to apply to each item in the sequence.
<DT><B>Returns:</B><DD>a Observable that emits a sequence that is the result of applying the transformation
         closure to each item in the sequence emitted by the input Observable.</DL>
</DD>
</DL>
<HR>

<A NAME="mapMany(rx.util.functions.Func1)"><!-- --></A><H3>
mapMany</H3>
<PRE>
public &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mapMany</B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt;&gt;&nbsp;func)</PRE>
<DL>
<DD>Creates a new Observable sequence by applying a closure that you supply to each item in the
 original Observable sequence, where that closure is itself a Observable that emits items, and
 then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.mapmany&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.mapMany.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - a closure to apply to each item in the sequence, that returns a Observable.
<DT><B>Returns:</B><DD>a Observable that emits a sequence that is the result of applying the transformation
         function to each item in the input sequence and merging the results of the
         Observables obtained from this transformation.</DL>
</DD>
</DL>
<HR>

<A NAME="mapMany(java.lang.Object)"><!-- --></A><H3>
mapMany</H3>
<PRE>
public &lt;R&gt; <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;R&gt; <B>mapMany</B>(java.lang.Object&nbsp;callback)</PRE>
<DL>
<DD>Creates a new Observable sequence by applying a closure that you supply to each item in the
 original Observable sequence, where that closure is itself a Observable that emits items, and
 then merges the results of that closure applied to every item emitted by the original
 Observable, emitting these merged results as its own sequence.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.mapmany&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.mapMany.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>callback</CODE> - a closure to apply to each item in the sequence that returns a Observable.
<DT><B>Returns:</B><DD>a Observable that emits a sequence that is the result of applying the transformation'
         function to each item in the input sequence and merging the results of the
         Observables obtained from this transformation.</DL>
</DD>
</DL>
<HR>

<A NAME="materialize()"><!-- --></A><H3>
materialize</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Notification.html" title="class in rx">Notification</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>materialize</B>()</PRE>
<DL>
<DD>Materializes the implicit notifications of this observable sequence as explicit notification values.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.materialize&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.materialize.png"></a>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An observable sequence whose elements are the result of materializing the notifications of the given sequence.<DT><B>See Also:</B><DD><CODE>http://msdn.microsoft.com/en-us/library/hh229453(v=VS.103).aspx</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(rx.util.functions.Func1)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorResumeNext</B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt;&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instruct a Observable to pass control to another Observable rather than calling <code>onError</code> if it encounters an error.
 
 By default, when a Observable encounters an error that prevents it from emitting the expected
 item to its Observer, the Observable calls its Observer's <code>onError</code> closure, and
 then quits without calling any more of its Observer's closures. The
 <code>onErrorResumeNext</code> method changes this behavior. If you pass another Observable
 (<code>resumeFunction</code>) to a Observable's <code>onErrorResumeNext</code> method, if the
 original Observable encounters an error, instead of calling its Observer's
 <code>onErrort</code> closure, it will instead relinquish control to
 <code>resumeFunction</code> which will call the Observer's <code>onNext</code> method if it
 is able to do so. In such a case, because no Observable necessarily invokes
 <code>onError</code>, the Observer may never know that an error happened.
 
 You can use this to prevent errors from propagating or to supply fallback data should errors
 be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorresumenext&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorresumenext.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeFunction</CODE> - 
<DT><B>Returns:</B><DD>the original Observable, with appropriately modified behavior</DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(java.lang.Object)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorResumeNext</B>(java.lang.Object&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instruct a Observable to emit a particular item rather than calling <code>onError</code> if
 it encounters an error.
 
 By default, when a Observable encounters an error that prevents it from emitting the expected
 item to its Observer, the Observable calls its Observer's <code>onError</code> closure, and
 then quits without calling any more of its Observer's closures. The
 <code>onErrorResumeNext</code> method changes this behavior. If you pass another Observable
 (<code>resumeFunction</code>) to a Observable's <code>onErrorResumeNext</code> method, if the
 original Observable encounters an error, instead of calling its Observer's
 <code>onError</code> closure, it will instead relinquish control to
 <code>resumeFunction</code> which will call the Observer's <code>onNext</code> method if it
 is able to do so. In such a case, because no Observable necessarily invokes
 <code>onError</code>, the Observer may never know that an error happened.
 
 You can use this to prevent errors from propagating or to supply fallback data should errors
 be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorresumenext&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorresumenext.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeFunction</CODE> - 
<DT><B>Returns:</B><DD>the original Observable with appropriately modified behavior</DL>
</DD>
</DL>
<HR>

<A NAME="onErrorResumeNext(rx.Observable)"><!-- --></A><H3>
onErrorResumeNext</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorResumeNext</B>(<A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeSequence)</PRE>
<DL>
<DD>Instruct a Observable to pass control to another Observable rather than calling
 <code>onError</code> if it encounters an error.
 
 By default, when a Observable encounters an error that prevents it from emitting the expected
 item to its Observer, the Observable calls its Observer's <code>onError</code> closure, and
 then quits without calling any more of its Observer's closures. The
 <code>onErrorResumeNext</code> method changes this behavior. If you pass another Observable
 (<code>resumeSequence</code>) to a Observable's <code>onErrorResumeNext</code> method, if the
 original Observable encounters an error, instead of calling its Observer's
 <code>onError</code> closure, it will instead relinquish control to
 <code>resumeSequence</code> which will call the Observer's <code>onNext</code> method if it
 is able to do so. In such a case, because no Observable necessarily invokes
 <code>onError</code>, the Observer may never know that an error happened.
 
 You can use this to prevent errors from propagating or to supply fallback data should errors
 be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorresumenext&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorresumenext.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeSequence</CODE> - 
<DT><B>Returns:</B><DD>the original Observable, with appropriately modified behavior</DL>
</DD>
</DL>
<HR>

<A NAME="onErrorReturn(rx.util.functions.Func1)"><!-- --></A><H3>
onErrorReturn</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorReturn</B>(<A HREF="../rx/util/functions/Func1.html" title="interface in rx.util.functions">Func1</A>&lt;java.lang.Exception,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instruct a Observable to emit a particular item rather than calling <code>onError</code> if
 it encounters an error.
 
 By default, when a Observable encounters an error that prevents it from emitting the expected
 object to its Observer, the Observable calls its Observer's <code>onError</code> closure, and
 then quits without calling any more of its Observer's closures. The
 <code>onErrorReturn</code> method changes this behavior. If you pass a closure
 (<code>resumeFunction</code>) to a Observable's <code>onErrorReturn</code> method, if the
 original Observable encounters an error, instead of calling its Observer's
 <code>onError</code> closure, it will instead call pass the return value of
 <code>resumeFunction</code> to the Observer's <code>onNext</code> method.
 
 You can use this to prevent errors from propagating or to supply fallback data should errors
 be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorreturn&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorreturn.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>resumeFunction</CODE> - 
<DT><B>Returns:</B><DD>the original Observable with appropriately modified behavior</DL>
</DD>
</DL>
<HR>

<A NAME="onErrorReturn(java.lang.Object)"><!-- --></A><H3>
onErrorReturn</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>onErrorReturn</B>(java.lang.Object&nbsp;resumeFunction)</PRE>
<DL>
<DD>Instruct a Observable to emit a particular item rather than calling <code>onError</code> if
 it encounters an error.
 
 By default, when a Observable encounters an error that prevents it from emitting the expected
 object to its Observer, the Observable calls its Observer's <code>onError</code> closure, and
 then quits without calling any more of its Observer's closures. The
 <code>onErrorReturn</code> method changes this behavior. If you pass a closure
 (<code>resumeFunction</code>) to a Observable's <code>onErrorReturn</code> method, if the
 original Observable encounters an error, instead of calling its Observer's
 <code>onError</code> closure, it will instead call pass the return value of
 <code>resumeFunction</code> to the Observer's <code>onNext</code> method.
 
 You can use this to prevent errors from propagating or to supply fallback data should errors
 be encountered.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.onerrorreturn&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.onerrorreturn.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>that</CODE> - <DD><CODE>resumeFunction</CODE> - 
<DT><B>Returns:</B><DD>the original Observable with appropriately modified behavior</DL>
</DD>
</DL>
<HR>

<A NAME="reduce(rx.util.functions.Func2)"><!-- --></A><H3>
reduce</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>reduce</B>(<A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an
 <code>inject</code> method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence, whose result
            will be used in the next accumulator call (if applicable).
<DT><B>Returns:</B><DD>An observable sequence with a single element from the result of accumulating the
         output from the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="reduce(java.lang.Object)"><!-- --></A><H3>
reduce</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>reduce</B>(java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an
 <code>inject</code> method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence, whose result
            will be used in the next accumulator call (if applicable).
<DT><B>Returns:</B><DD>A Observable that emits a single element from the result of accumulating the output
         from the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="reduce(java.lang.Object,rx.util.functions.Func2)"><!-- --></A><A NAME="reduce(T, rx.util.functions.Func2)"><!-- --></A><H3>
reduce</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>reduce</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
                            <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an
 <code>inject</code> method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - The initial (seed) accumulator value.<DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence, whose
            result will be used in the next accumulator call (if applicable).
<DT><B>Returns:</B><DD>A Observable that emits a single element from the result of accumulating the output
         from the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="reduce(java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="reduce(T, java.lang.Object)"><!-- --></A><H3>
reduce</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>reduce</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
                            java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the final result from the final call to your closure as its sole
 output.
 <p>
 This technique, which is called "reduce" here, is sometimes called "fold," "accumulate,"
 "compress," or "inject" in other programming contexts. Groovy, for instance, has an
 <code>inject</code> method that does a similar operation on lists.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.reduce&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.reduce.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - The initial (seed) accumulator value.<DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence, whose
            result will be used in the next accumulator call (if applicable).
<DT><B>Returns:</B><DD>A Observable that emits a single element from the result of accumulating the output
         from the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx">MSDN: Observable.Aggregate</a>, 
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(rx.util.functions.Func2)"><!-- --></A><H3>
scan</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>scan</B>(<A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations. It emits the result of
 each of these iterations as a sequence from the returned Observable. This sort of closure is
 sometimes called an accumulator.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/showgliffyeditor.action?name=marble.scan.noseed&ceoid=27321465&key=API&pageId=27321465&t=marble.scan.noseed"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.noseed.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence whose
            result will be sent via <code>onNext</code> and used in the next accumulator call
            (if applicable).
<DT><B>Returns:</B><DD>A Observable sequence whose elements are the result of accumulating the output from
         the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(java.lang.Object)"><!-- --></A><H3>
scan</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>scan</B>(java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations. It emits the result of
 each of these iterations as a sequence from the returned Observable. This sort of closure is
 sometimes called an accumulator.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/showgliffyeditor.action?name=marble.scan.noseed&ceoid=27321465&key=API&pageId=27321465&t=marble.scan.noseed"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.noseed.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence whose
            result will be sent via <code>onNext</code> and used in the next accumulator call
            (if applicable).
<DT><B>Returns:</B><DD>A Observable sequence whose elements are the result of accumulating the output from
         the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(java.lang.Object,rx.util.functions.Func2)"><!-- --></A><A NAME="scan(T, rx.util.functions.Func2)"><!-- --></A><H3>
scan</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>scan</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
                          <A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, and so on until all items have been emitted by the
 source Observable, emitting the result of each of these iterations. This sort of closure is
 sometimes called an accumulator.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.scan&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - The initial (seed) accumulator value.<DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence whose
            result will be sent via <code>onNext</code> and used in the next accumulator call
            (if applicable).
<DT><B>Returns:</B><DD>A Observable sequence whose elements are the result of accumulating the output from
         the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="scan(java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="scan(T, java.lang.Object)"><!-- --></A><H3>
scan</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>scan</B>(<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&nbsp;initialValue,
                          java.lang.Object&nbsp;accumulator)</PRE>
<DL>
<DD>Returns a Observable that applies a closure of your choosing to the first item emitted by a
 source Observable, then feeds the result of that closure along with the second item emitted
 by a Observable into the same closure, then feeds the result of that closure along with the
 third item into the same closure, and so on, emitting the result of each of these
 iterations. This sort of closure is sometimes called an accumulator.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.scan&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.scan.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>initialValue</CODE> - The initial (seed) accumulator value.<DD><CODE>accumulator</CODE> - An accumulator closure to be invoked on each element from the sequence whose result
            will be sent via <code>onNext</code> and used in the next accumulator call (if
            applicable).
<DT><B>Returns:</B><DD>A Observable sequence whose elements are the result of accumulating the output from
         the list of Observables.<DT><B>See Also:</B><DD><a href="http://msdn.microsoft.com/en-us/library/hh211665(v%3Dvs.103).aspx">MSDN: Observable.Scan</a></DL>
</DD>
</DL>
<HR>

<A NAME="skip(int)"><!-- --></A><H3>
skip</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>skip</B>(int&nbsp;num)</PRE>
<DL>
<DD>Returns a Observable that skips the first <code>num</code> items emitted by the source
 Observable.
 You can ignore the first <code>num</code> items emitted by a Observable and attend only to
 those items that come after, by modifying the Observable with the <code>skip</code> method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.skip&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.skip.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>num</CODE> - The number of items to skip
<DT><B>Returns:</B><DD>A Observable sequence that is identical to the source Observable except that it does
         not emit the first <code>num</code> items from that sequence.</DL>
</DD>
</DL>
<HR>

<A NAME="take(int)"><!-- --></A><H3>
take</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt; <B>take</B>(int&nbsp;num)</PRE>
<DL>
<DD>Returns a Observable that emits the first <code>num</code> items emitted by the source
 Observable.
 
 You can choose to pay attention only to the first <code>num</code> values emitted by a
 Observable by calling its <code>take</code> method. This method returns a Observable that will
 call a subscribing Observer's <code>onNext</code> closure a maximum of <code>num</code> times
 before calling <code>onCompleted</code>.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.take&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.take.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>num</CODE> - 
<DT><B>Returns:</B><DD>a Observable that emits only the first <code>num</code> items from the source
         Observable, or all of the items from the source Observable if that Observable emits
         fewer than <code>num</code> items.</DL>
</DD>
</DL>
<HR>

<A NAME="toList()"><!-- --></A><H3>
toList</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toList</B>()</PRE>
<DL>
<DD>Returns a Observable that emits a single item, a list composed of all the items emitted by
 the source Observable.
 
 Normally, a Observable that returns multiple items will do so by calling its Observer's
 <code>onNext</code> closure for each such item. You can change this behavior, instructing
 the Observable to compose a list of all of these multiple items and then to call the
 Observer's <code>onNext</code> closure once, passing it the entire list, by calling the
 Observable object's <code>toList</code> method prior to calling its <code>subscribe</code>
 method.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolist&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolist.png"></a>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a Observable that emits a single item: a List containing all of the items emitted by
         the source Observable.</DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList()"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toSortedList</B>()</PRE>
<DL>
<DD>Sort T objects by their natural order (object must implement Comparable).
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolistsorted&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolistsorted.png"></a>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if T objects do not implement Comparable</DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList(rx.util.functions.Func2)"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toSortedList</B>(<A HREF="../rx/util/functions/Func2.html" title="interface in rx.util.functions">Func2</A>&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>,java.lang.Integer&gt;&nbsp;sortFunction)</PRE>
<DL>
<DD>Sort T objects using the defined sort function.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolistsorted&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolistsorted.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sortFunction</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="toSortedList(java.lang.Object)"><!-- --></A><H3>
toSortedList</H3>
<PRE>
public <A HREF="../rx/Observable.html" title="class in rx">Observable</A>&lt;java.util.List&lt;<A HREF="../rx/Observable.html" title="type parameter in Observable">T</A>&gt;&gt; <B>toSortedList</B>(java.lang.Object&nbsp;sortFunction)</PRE>
<DL>
<DD>Sort T objects using the defined sort function.
 <p>
 <a href="https://confluence.corp.netflix.com/plugins/gliffy/viewlargediagram.action?name=marble.tolistsorted&ceoid=27321465&key=API&pageId=27321465"><img
 src="https://confluence.corp.netflix.com/download/attachments/27321465/marble.tolistsorted.png"></a>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sortFunction</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../rx/Notification.Kind.html" title="enum in rx"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../rx/Observer.html" title="interface in rx"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?rx/Observable.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Observable.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
