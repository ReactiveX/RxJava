//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel-doppl/core-doppl/androidbase/src/main/java/android/database/sqlite/SQLiteConnectionPool.java
//

#include "AndroidDatabaseSqliteSQLiteConnection.h"
#include "AndroidDatabaseSqliteSQLiteConnectionPool.h"
#include "AndroidDatabaseSqliteSQLiteDatabase.h"
#include "AndroidDatabaseSqliteSQLiteDatabaseConfiguration.h"
#include "AndroidDatabaseSqliteSQLiteGlobal.h"
#include "AndroidUtilPrefixPrinter.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "android/os/SystemClock.h"
#include "android/util/Log.h"
#include "android/util/Printer.h"
#include "dalvik/system/CloseGuard.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Thread.h"
#include "java/util/ArrayList.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/WeakHashMap.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "java/util/concurrent/locks/LockSupport.h"

@class AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;

@interface AndroidDatabaseSqliteSQLiteConnectionPool () {
 @public
  DalvikSystemCloseGuard *mCloseGuard_;
  id mLock_;
  JavaUtilConcurrentAtomicAtomicBoolean *mConnectionLeaked_;
  AndroidDatabaseSqliteSQLiteDatabaseConfiguration *mConfiguration_;
  jint mMaxConnectionPoolSize_;
  jboolean mIsOpen_;
  jint mNextConnectionId_;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *mConnectionWaiterPool_;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *mConnectionWaiterQueue_;
  JavaUtilArrayList *mAvailableNonPrimaryConnections_;
  AndroidDatabaseSqliteSQLiteConnection *mAvailablePrimaryConnection_;
  JavaUtilWeakHashMap *mAcquiredConnections_;
}

- (instancetype)initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration;

- (void)open;

- (void)disposeWithBoolean:(jboolean)finalized;

- (jboolean)recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
      withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status;

- (AndroidDatabaseSqliteSQLiteConnection *)openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration
                                                                                                        withBoolean:(jboolean)primaryConnection;

- (void)closeAvailableConnectionsAndLogExceptionsLocked;

- (void)closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked;

- (void)closeExcessConnectionsAndLogExceptionsLocked;

- (void)closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection;

- (void)discardAcquiredConnectionsLocked;

- (void)reconfigureAllConnectionsLocked;

- (void)markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status;

- (AndroidDatabaseSqliteSQLiteConnection *)waitForConnectionWithNSString:(NSString *)sql
                                                                 withInt:(jint)connectionFlags;

- (void)logConnectionPoolBusyLockedWithLong:(jlong)waitMillis
                                    withInt:(jint)connectionFlags;

- (void)wakeConnectionWaitersLocked;

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquirePrimaryConnectionLockedWithInt:(jint)connectionFlags;

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquireNonPrimaryConnectionLockedWithNSString:(NSString *)sql
                                                                                    withInt:(jint)connectionFlags;

- (void)finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
                                                                       withInt:(jint)connectionFlags;

- (jboolean)isSessionBlockingImportantConnectionWaitersLockedWithBoolean:(jboolean)holdingPrimaryConnection
                                                                 withInt:(jint)connectionFlags;

+ (jint)getPriorityWithInt:(jint)connectionFlags;

- (void)setMaxConnectionPoolSizeLocked;

- (void)throwIfClosedLocked;

- (AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)obtainConnectionWaiterLockedWithJavaLangThread:(JavaLangThread *)thread
                                                                                                      withLong:(jlong)startTime
                                                                                                       withInt:(jint)priority
                                                                                                   withBoolean:(jboolean)wantPrimaryConnection
                                                                                                  withNSString:(NSString *)sql
                                                                                                       withInt:(jint)connectionFlags;

- (void)recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter:(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)waiter;

@end

J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mCloseGuard_, DalvikSystemCloseGuard *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mLock_, id)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConnectionLeaked_, JavaUtilConcurrentAtomicAtomicBoolean *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConfiguration_, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConnectionWaiterPool_, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mConnectionWaiterQueue_, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mAvailableNonPrimaryConnections_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mAvailablePrimaryConnection_, AndroidDatabaseSqliteSQLiteConnection *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool, mAcquiredConnections_, JavaUtilWeakHashMap *)

inline NSString *AndroidDatabaseSqliteSQLiteConnectionPool_get_TAG();
static NSString *AndroidDatabaseSqliteSQLiteConnectionPool_TAG = @"SQLiteConnectionPool";
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidDatabaseSqliteSQLiteConnectionPool, TAG, NSString *)

inline jlong AndroidDatabaseSqliteSQLiteConnectionPool_get_CONNECTION_POOL_BUSY_MILLIS();
#define AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS 30000LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidDatabaseSqliteSQLiteConnectionPool, CONNECTION_POOL_BUSY_MILLIS, jlong)

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool *new_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) NS_RETURNS_RETAINED;

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool *create_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_open(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean finalized);

__attribute__((unused)) static jboolean AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration, jboolean primaryConnection);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jlong waitMillis, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jint connectionFlags);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, jint connectionFlags);

__attribute__((unused)) static jboolean AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean holdingPrimaryConnection, jint connectionFlags);

__attribute__((unused)) static jint AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, JavaLangThread *thread, jlong startTime, jint priority, jboolean wantPrimaryConnection, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *self, NSString *__name, jint __ordinal);

@interface AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter : NSObject {
 @public
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *mNext_;
  JavaLangThread *mThread_;
  jlong mStartTime_;
  jint mPriority_;
  jboolean mWantPrimaryConnection_;
  NSString *mSql_;
  jint mConnectionFlags_;
  AndroidDatabaseSqliteSQLiteConnection *mAssignedConnection_;
  JavaLangRuntimeException *mException_;
  jint mNonce_;
}

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter)

J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mNext_, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mThread_, JavaLangThread *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mSql_, NSString *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mAssignedConnection_, AndroidDatabaseSqliteSQLiteConnection *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, mException_, JavaLangRuntimeException *)

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *new_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *create_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init();

J2OBJC_TYPE_LITERAL_HEADER(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter)

@implementation AndroidDatabaseSqliteSQLiteConnectionPool

- (instancetype)initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration {
  AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(self, configuration);
  return self;
}

- (void)javaFinalize {
  @try {
    AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(self, true);
  }
  @finally {
    [super javaFinalize];
  }
}

+ (AndroidDatabaseSqliteSQLiteConnectionPool *)openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration {
  return AndroidDatabaseSqliteSQLiteConnectionPool_openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(configuration);
}

- (void)open {
  AndroidDatabaseSqliteSQLiteConnectionPool_open(self);
}

- (void)close {
  AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(self, false);
}

- (void)disposeWithBoolean:(jboolean)finalized {
  AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(self, finalized);
}

- (void)reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration {
  if (configuration == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"configuration must not be null.");
  }
  @synchronized(mLock_) {
    AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
    jboolean walModeChanged = ((configuration->openFlags_ ^ ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->openFlags_) & AndroidDatabaseSqliteSQLiteDatabase_ENABLE_WRITE_AHEAD_LOGGING) != 0;
    if (walModeChanged) {
      if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
        @throw create_JavaLangIllegalStateException_initWithNSString_(@"Write Ahead Logging (WAL) mode cannot be enabled or disabled while there are transactions in progress.  Finish all transactions and release all active database connections first.");
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
      JreAssert(([((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) isEmpty]), (@"android/database/sqlite/SQLiteConnectionPool.java:277 condition failed: assert mAvailableNonPrimaryConnections.isEmpty();"));
    }
    jboolean foreignKeyModeChanged = configuration->foreignKeyConstraintsEnabled_ != mConfiguration_->foreignKeyConstraintsEnabled_;
    if (foreignKeyModeChanged) {
      if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
        @throw create_JavaLangIllegalStateException_initWithNSString_(@"Foreign Key Constraints cannot be enabled or disabled while there are transactions in progress.  Finish all transactions and release all active database connections first.");
      }
    }
    if (mConfiguration_->openFlags_ != configuration->openFlags_) {
      if (walModeChanged) {
        AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      }
      AndroidDatabaseSqliteSQLiteConnection *newPrimaryConnection = AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, configuration, true);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(self);
      JreStrongAssign(&mAvailablePrimaryConnection_, newPrimaryConnection);
      [mConfiguration_ updateParametersFromWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:configuration];
      AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
    }
    else {
      [mConfiguration_ updateParametersFromWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:configuration];
      AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(self);
      AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(self);
    }
    AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
  }
}

- (AndroidDatabaseSqliteSQLiteConnection *)acquireConnectionWithNSString:(NSString *)sql
                                                                 withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)releaseConnectionWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection {
  @synchronized(mLock_) {
    AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status = [((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) removeWithId:connection];
    if (status == nil) {
      @throw create_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the specified connection was not acquired from this pool or has already been released.");
    }
    if (!mIsOpen_) {
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    }
    else if ([((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) isPrimaryConnection]) {
      if (AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status)) {
        JreAssert((mAvailablePrimaryConnection_ == nil), (@"android/database/sqlite/SQLiteConnectionPool.java:373 condition failed: assert mAvailablePrimaryConnection == null;"));
        JreStrongAssign(&mAvailablePrimaryConnection_, connection);
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
    else if ([((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) size] >= mMaxConnectionPoolSize_ - 1) {
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    }
    else {
      if (AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status)) {
        [mAvailableNonPrimaryConnections_ addWithId:connection];
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
  }
}

- (jboolean)recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
      withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status {
  return AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status);
}

- (jboolean)shouldYieldConnectionWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
                                                                   withInt:(jint)connectionFlags {
  @synchronized(mLock_) {
    if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) containsKeyWithId:connection]) {
      @throw create_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the specified connection was not acquired from this pool or has already been released.");
    }
    if (!mIsOpen_) {
      return false;
    }
    return AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(self, [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) isPrimaryConnection], connectionFlags);
  }
}

- (void)collectDbStatsWithJavaUtilArrayList:(JavaUtilArrayList *)dbStatsList {
  @synchronized(mLock_) {
    if (mAvailablePrimaryConnection_ != nil) {
      [mAvailablePrimaryConnection_ collectDbStatsWithJavaUtilArrayList:dbStatsList];
    }
    for (AndroidDatabaseSqliteSQLiteConnection * __strong connection in nil_chk(mAvailableNonPrimaryConnections_)) {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) collectDbStatsWithJavaUtilArrayList:dbStatsList];
    }
    for (AndroidDatabaseSqliteSQLiteConnection * __strong connection in nil_chk([((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) keySet])) {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) collectDbStatsUnsafeWithJavaUtilArrayList:dbStatsList];
    }
  }
}

- (AndroidDatabaseSqliteSQLiteConnection *)openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *)configuration
                                                                                                        withBoolean:(jboolean)primaryConnection {
  return AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, configuration, primaryConnection);
}

- (void)onConnectionLeaked {
  AndroidUtilLog_wWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$$$", @"A SQLiteConnection object for database '", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->label_, @"' was leaked!  Please fix your application to end transactions in progress properly and to close the database when it is no longer needed."));
  [((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(mConnectionLeaked_)) setWithBoolean:true];
}

- (void)closeAvailableConnectionsAndLogExceptionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
}

- (void)closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
}

- (void)closeExcessConnectionsAndLogExceptionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(self);
}

- (void)closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
}

- (void)discardAcquiredConnectionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(self);
}

- (void)reconfigureAllConnectionsLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(self);
}

- (void)markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)status {
  AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, status);
}

- (AndroidDatabaseSqliteSQLiteConnection *)waitForConnectionWithNSString:(NSString *)sql
                                                                 withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)logConnectionPoolBusyLockedWithLong:(jlong)waitMillis
                                    withInt:(jint)connectionFlags {
  AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(self, waitMillis, connectionFlags);
}

- (void)wakeConnectionWaitersLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
}

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquirePrimaryConnectionLockedWithInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, connectionFlags);
}

- (AndroidDatabaseSqliteSQLiteConnection *)tryAcquireNonPrimaryConnectionLockedWithNSString:(NSString *)sql
                                                                                    withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:(AndroidDatabaseSqliteSQLiteConnection *)connection
                                                                       withInt:(jint)connectionFlags {
  AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
}

- (jboolean)isSessionBlockingImportantConnectionWaitersLockedWithBoolean:(jboolean)holdingPrimaryConnection
                                                                 withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(self, holdingPrimaryConnection, connectionFlags);
}

+ (jint)getPriorityWithInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
}

- (void)setMaxConnectionPoolSizeLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
}

- (void)throwIfClosedLocked {
  AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
}

- (AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)obtainConnectionWaiterLockedWithJavaLangThread:(JavaLangThread *)thread
                                                                                                      withLong:(jlong)startTime
                                                                                                       withInt:(jint)priority
                                                                                                   withBoolean:(jboolean)wantPrimaryConnection
                                                                                                  withNSString:(NSString *)sql
                                                                                                       withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(self, thread, startTime, priority, wantPrimaryConnection, sql, connectionFlags);
}

- (void)recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter:(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *)waiter {
  AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(self, waiter);
}

- (void)dumpWithAndroidUtilPrinter:(id<AndroidUtilPrinter>)printer
                       withBoolean:(jboolean)verbose {
  id<AndroidUtilPrinter> indentedPrinter = AndroidUtilPrefixPrinter_createWithAndroidUtilPrinter_withNSString_(printer, @"    ");
  @synchronized(mLock_) {
    [((id<AndroidUtilPrinter>) nil_chk(printer)) printlnWithNSString:JreStrcat("$$C", @"Connection pool for ", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->path_, ':')];
    [printer printlnWithNSString:JreStrcat("$Z", @"  Open: ", mIsOpen_)];
    [printer printlnWithNSString:JreStrcat("$I", @"  Max connections: ", mMaxConnectionPoolSize_)];
    [printer printlnWithNSString:@"  Available primary connection:"];
    if (mAvailablePrimaryConnection_ != nil) {
      [mAvailablePrimaryConnection_ dumpWithAndroidUtilPrinter:indentedPrinter withBoolean:verbose];
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Available non-primary connections:"];
    if (![((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) isEmpty]) {
      jint count = [mAvailableNonPrimaryConnections_ size];
      for (jint i = 0; i < count; i++) {
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk([mAvailableNonPrimaryConnections_ getWithInt:i])) dumpWithAndroidUtilPrinter:indentedPrinter withBoolean:verbose];
      }
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Acquired connections:"];
    if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
      for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([mAcquiredConnections_ entrySet])) {
        AndroidDatabaseSqliteSQLiteConnection *connection = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey];
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) dumpUnsafeWithAndroidUtilPrinter:indentedPrinter withBoolean:verbose];
        [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:JreStrcat("$@", @"  Status: ", [entry_ getValue])];
      }
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Connection waiters:"];
    if (mConnectionWaiterQueue_ != nil) {
      jint i = 0;
      jlong now = AndroidOsSystemClock_uptimeMillis();
      for (AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = mConnectionWaiterQueue_; waiter != nil; waiter = waiter->mNext_, i++) {
        [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:JreStrcat("I$F$@$I$$C", i, @": waited for ", ((now - waiter->mStartTime_) * 0.001f), @" ms - thread=", waiter->mThread_, @", priority=", waiter->mPriority_, @", sql='", waiter->mSql_, '\'')];
      }
    }
    else {
      [((id<AndroidUtilPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
  }
}

- (NSString *)description {
  return JreStrcat("$$", @"SQLiteConnectionPool: ", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->path_);
}

- (void)dealloc {
  JreCheckFinalize(self, [AndroidDatabaseSqliteSQLiteConnectionPool class]);
  RELEASE_(mCloseGuard_);
  RELEASE_(mLock_);
  RELEASE_(mConnectionLeaked_);
  RELEASE_(mConfiguration_);
  RELEASE_(mConnectionWaiterPool_);
  RELEASE_(mConnectionWaiterQueue_);
  RELEASE_(mAvailableNonPrimaryConnections_);
  RELEASE_(mAvailablePrimaryConnection_);
  RELEASE_(mAcquiredConnections_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 1, -1, 2, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnectionPool;", 0x9, 3, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 0, -1, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnection;", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 16, -1, 17, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnection;", 0x2, 18, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnection;", 0x2, 23, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 24, 25, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnection;", 0x2, 26, 27, -1, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnection;", 0x2, 28, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 29, 14, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 30, 31, -1, -1, -1, -1 },
    { NULL, "I", 0xa, 32, 27, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;", 0x2, 33, 34, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 35, 36, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 37, 38, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 39, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:);
  methods[1].selector = @selector(javaFinalize);
  methods[2].selector = @selector(openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:);
  methods[3].selector = @selector(open);
  methods[4].selector = @selector(close);
  methods[5].selector = @selector(disposeWithBoolean:);
  methods[6].selector = @selector(reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:);
  methods[7].selector = @selector(acquireConnectionWithNSString:withInt:);
  methods[8].selector = @selector(releaseConnectionWithAndroidDatabaseSqliteSQLiteConnection:);
  methods[9].selector = @selector(recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:);
  methods[10].selector = @selector(shouldYieldConnectionWithAndroidDatabaseSqliteSQLiteConnection:withInt:);
  methods[11].selector = @selector(collectDbStatsWithJavaUtilArrayList:);
  methods[12].selector = @selector(openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:withBoolean:);
  methods[13].selector = @selector(onConnectionLeaked);
  methods[14].selector = @selector(closeAvailableConnectionsAndLogExceptionsLocked);
  methods[15].selector = @selector(closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked);
  methods[16].selector = @selector(closeExcessConnectionsAndLogExceptionsLocked);
  methods[17].selector = @selector(closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection:);
  methods[18].selector = @selector(discardAcquiredConnectionsLocked);
  methods[19].selector = @selector(reconfigureAllConnectionsLocked);
  methods[20].selector = @selector(markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus:);
  methods[21].selector = @selector(waitForConnectionWithNSString:withInt:);
  methods[22].selector = @selector(logConnectionPoolBusyLockedWithLong:withInt:);
  methods[23].selector = @selector(wakeConnectionWaitersLocked);
  methods[24].selector = @selector(tryAcquirePrimaryConnectionLockedWithInt:);
  methods[25].selector = @selector(tryAcquireNonPrimaryConnectionLockedWithNSString:withInt:);
  methods[26].selector = @selector(finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection:withInt:);
  methods[27].selector = @selector(isSessionBlockingImportantConnectionWaitersLockedWithBoolean:withInt:);
  methods[28].selector = @selector(getPriorityWithInt:);
  methods[29].selector = @selector(setMaxConnectionPoolSizeLocked);
  methods[30].selector = @selector(throwIfClosedLocked);
  methods[31].selector = @selector(obtainConnectionWaiterLockedWithJavaLangThread:withLong:withInt:withBoolean:withNSString:withInt:);
  methods[32].selector = @selector(recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter:);
  methods[33].selector = @selector(dumpWithAndroidUtilPrinter:withBoolean:);
  methods[34].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 40, -1, -1 },
    { "CONNECTION_POOL_BUSY_MILLIS", "J", .constantValue.asLong = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS, 0x1a, -1, -1, -1, -1 },
    { "mCloseGuard_", "LDalvikSystemCloseGuard;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mLock_", "LNSObject;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mConnectionLeaked_", "LJavaUtilConcurrentAtomicAtomicBoolean;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mConfiguration_", "LAndroidDatabaseSqliteSQLiteDatabaseConfiguration;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mMaxConnectionPoolSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mIsOpen_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mNextConnectionId_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mConnectionWaiterPool_", "LAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mConnectionWaiterQueue_", "LAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAvailableNonPrimaryConnections_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x12, -1, -1, 41, -1 },
    { "mAvailablePrimaryConnection_", "LAndroidDatabaseSqliteSQLiteConnection;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAcquiredConnections_", "LJavaUtilWeakHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 42, -1 },
    { "CONNECTION_FLAG_READ_ONLY", "I", .constantValue.asInt = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_READ_ONLY, 0x19, -1, -1, -1, -1 },
    { "CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY", "I", .constantValue.asInt = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY, 0x19, -1, -1, -1, -1 },
    { "CONNECTION_FLAG_INTERACTIVE", "I", .constantValue.asInt = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_INTERACTIVE, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidDatabaseSqliteSQLiteDatabaseConfiguration;", "finalize", "LNSException;", "open", "dispose", "Z", "reconfigure", "acquireConnection", "LNSString;I", "releaseConnection", "LAndroidDatabaseSqliteSQLiteConnection;", "recycleConnectionLocked", "LAndroidDatabaseSqliteSQLiteConnection;LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;", "shouldYieldConnection", "LAndroidDatabaseSqliteSQLiteConnection;I", "collectDbStats", "LJavaUtilArrayList;", "(Ljava/util/ArrayList<Landroid/database/sqlite/SQLiteDebug$DbStats;>;)V", "openConnectionLocked", "LAndroidDatabaseSqliteSQLiteDatabaseConfiguration;Z", "closeConnectionAndLogExceptionsLocked", "markAcquiredConnectionsLocked", "LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;", "waitForConnection", "logConnectionPoolBusyLocked", "JI", "tryAcquirePrimaryConnectionLocked", "I", "tryAcquireNonPrimaryConnectionLocked", "finishAcquireConnectionLocked", "isSessionBlockingImportantConnectionWaitersLocked", "ZI", "getPriority", "obtainConnectionWaiterLocked", "LJavaLangThread;JIZLNSString;I", "recycleConnectionWaiterLocked", "LAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;", "dump", "LAndroidUtilPrinter;Z", "toString", &AndroidDatabaseSqliteSQLiteConnectionPool_TAG, "Ljava/util/ArrayList<Landroid/database/sqlite/SQLiteConnection;>;", "Ljava/util/WeakHashMap<Landroid/database/sqlite/SQLiteConnection;Landroid/database/sqlite/SQLiteConnectionPool$AcquiredConnectionStatus;>;", "LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;LAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;" };
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteConnectionPool = { "SQLiteConnectionPool", "android.database.sqlite", ptrTable, methods, fields, 7, 0x11, 35, 17, -1, 43, -1, -1, -1 };
  return &_AndroidDatabaseSqliteSQLiteConnectionPool;
}

@end

void AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  NSObject_init(self);
  JreStrongAssign(&self->mCloseGuard_, DalvikSystemCloseGuard_get());
  JreStrongAssignAndConsume(&self->mLock_, new_NSObject_init());
  JreStrongAssignAndConsume(&self->mConnectionLeaked_, new_JavaUtilConcurrentAtomicAtomicBoolean_init());
  JreStrongAssignAndConsume(&self->mAvailableNonPrimaryConnections_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&self->mAcquiredConnections_, new_JavaUtilWeakHashMap_init());
  JreStrongAssignAndConsume(&self->mConfiguration_, new_AndroidDatabaseSqliteSQLiteDatabaseConfiguration_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(configuration));
  AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
}

AndroidDatabaseSqliteSQLiteConnectionPool *new_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  J2OBJC_NEW_IMPL(AndroidDatabaseSqliteSQLiteConnectionPool, initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_, configuration)
}

AndroidDatabaseSqliteSQLiteConnectionPool *create_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  J2OBJC_CREATE_IMPL(AndroidDatabaseSqliteSQLiteConnectionPool, initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_, configuration)
}

AndroidDatabaseSqliteSQLiteConnectionPool *AndroidDatabaseSqliteSQLiteConnectionPool_openWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration) {
  AndroidDatabaseSqliteSQLiteConnectionPool_initialize();
  if (configuration == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"configuration must not be null.");
  }
  AndroidDatabaseSqliteSQLiteConnectionPool *pool = create_AndroidDatabaseSqliteSQLiteConnectionPool_initWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_(configuration);
  AndroidDatabaseSqliteSQLiteConnectionPool_open(pool);
  return pool;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_open(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  JreStrongAssign(&self->mAvailablePrimaryConnection_, AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, true));
  self->mIsOpen_ = true;
  [((DalvikSystemCloseGuard *) nil_chk(self->mCloseGuard_)) openWithNSString:@"close"];
}

void AndroidDatabaseSqliteSQLiteConnectionPool_disposeWithBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean finalized) {
  if (self->mCloseGuard_ != nil) {
    if (finalized) {
      [self->mCloseGuard_ warnIfOpen];
    }
    [self->mCloseGuard_ close];
  }
  if (!finalized) {
    @synchronized(self->mLock_) {
      AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
      self->mIsOpen_ = false;
      AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      jint pendingCount = [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) size];
      if (pendingCount != 0) {
        AndroidUtilLog_iWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$$$I$", @"The connection pool for ", ((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->label_, @" has been closed but there are still ", pendingCount, @" connections in use.  They will be closed as they are released back to the pool."));
      }
      AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
  }
}

jboolean AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status) {
  if (status == JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE)) {
    @try {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure released connection, closing it: ", connection), ex);
      status = JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD);
    }
  }
  if (status == JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD)) {
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    return false;
  }
  return true;
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteDatabaseConfiguration *configuration, jboolean primaryConnection) {
  jint connectionId = self->mNextConnectionId_++;
  return AndroidDatabaseSqliteSQLiteConnection_openWithAndroidDatabaseSqliteSQLiteConnectionPool_withAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withInt_withBoolean_(self, configuration, connectionId, primaryConnection);
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
  if (self->mAvailablePrimaryConnection_ != nil) {
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, self->mAvailablePrimaryConnection_);
    JreStrongAssign(&self->mAvailablePrimaryConnection_, nil);
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  jint count = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  for (jint i = 0; i < count; i++) {
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, [self->mAvailableNonPrimaryConnections_ getWithInt:i]);
  }
  [self->mAvailableNonPrimaryConnections_ clear];
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  jint availableCount = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  while (availableCount-- > self->mMaxConnectionPoolSize_ - 1) {
    AndroidDatabaseSqliteSQLiteConnection *connection = [self->mAvailableNonPrimaryConnections_ removeWithInt:availableCount];
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection) {
  @try {
    [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) close];
  }
  @catch (JavaLangRuntimeException *ex) {
    AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to close connection, its fate is now in the hands of the merciful GC: ", connection), ex);
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_discardAcquiredConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD));
}

void AndroidDatabaseSqliteSQLiteConnectionPool_reconfigureAllConnectionsLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  if (self->mAvailablePrimaryConnection_ != nil) {
    @try {
      [self->mAvailablePrimaryConnection_ reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure available primary connection, closing it: ", self->mAvailablePrimaryConnection_), ex);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, self->mAvailablePrimaryConnection_);
      JreStrongAssign(&self->mAvailablePrimaryConnection_, nil);
    }
  }
  jint count = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  for (jint i = 0; i < count; i++) {
    AndroidDatabaseSqliteSQLiteConnection *connection = [self->mAvailableNonPrimaryConnections_ getWithInt:i];
    @try {
      [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) reconfigureWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      AndroidUtilLog_eWithNSString_withNSString_withNSException_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure available non-primary connection, closing it: ", connection), ex);
      AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
      [self->mAvailableNonPrimaryConnections_ removeWithInt:i--];
      count -= 1;
    }
  }
  AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(self, JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE));
}

void AndroidDatabaseSqliteSQLiteConnectionPool_markAcquiredConnectionsLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *status) {
  if (![((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) isEmpty]) {
    JavaUtilArrayList *keysToUpdate = create_JavaUtilArrayList_initWithInt_([self->mAcquiredConnections_ size]);
    for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([self->mAcquiredConnections_ entrySet])) {
      AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *oldStatus = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue];
      if (status != oldStatus && oldStatus != JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD)) {
        [keysToUpdate addWithId:[entry_ getKey]];
      }
    }
    jint updateCount = [keysToUpdate size];
    for (jint i = 0; i < updateCount; i++) {
      [self->mAcquiredConnections_ putWithId:[keysToUpdate getWithInt:i] withId:status];
    }
  }
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags) {
  jboolean wantPrimaryConnection = (connectionFlags & AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY) != 0;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter;
  jint nonce;
  @synchronized(self->mLock_) {
    AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
    AndroidDatabaseSqliteSQLiteConnection *connection = nil;
    if (!wantPrimaryConnection) {
      connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, sql, connectionFlags);
    }
    if (connection == nil) {
      connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, connectionFlags);
    }
    if (connection != nil) {
      return connection;
    }
    jint priority = AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
    jlong startTime = AndroidOsSystemClock_uptimeMillis();
    waiter = AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(self, JavaLangThread_currentThread(), startTime, priority, wantPrimaryConnection, sql, connectionFlags);
    AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *predecessor = nil;
    AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *successor = self->mConnectionWaiterQueue_;
    while (successor != nil) {
      if (priority > successor->mPriority_) {
        JreStrongAssign(&((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNext_, successor);
        break;
      }
      predecessor = successor;
      successor = successor->mNext_;
    }
    if (predecessor != nil) {
      JreStrongAssign(&predecessor->mNext_, waiter);
    }
    else {
      JreStrongAssign(&self->mConnectionWaiterQueue_, waiter);
    }
    nonce = ((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNonce_;
  }
  @try {
    jlong busyTimeoutMillis = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS;
    jlong nextBusyTimeoutTime = waiter->mStartTime_ + busyTimeoutMillis;
    for (; ; ) {
      if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(self->mConnectionLeaked_)) compareAndSetWithBoolean:true withBoolean:false]) {
        @synchronized(self->mLock_) {
          AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
        }
      }
      JavaUtilConcurrentLocksLockSupport_parkNanosWithId_withLong_(self, busyTimeoutMillis * 1000000LL);
      JavaLangThread_interrupted();
      @synchronized(self->mLock_) {
        AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(self);
        AndroidDatabaseSqliteSQLiteConnection *connection = waiter->mAssignedConnection_;
        JavaLangRuntimeException *ex = waiter->mException_;
        if (connection != nil || ex != nil) {
          AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(self, waiter);
          if (connection != nil) {
            return connection;
          }
          @throw ex;
        }
        jlong now = AndroidOsSystemClock_uptimeMillis();
        if (now < nextBusyTimeoutTime) {
          busyTimeoutMillis = now - nextBusyTimeoutTime;
        }
        else {
          AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(self, now - waiter->mStartTime_, connectionFlags);
          busyTimeoutMillis = AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS;
          nextBusyTimeoutTime = now + busyTimeoutMillis;
        }
      }
    }
  }
  @finally {
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jlong waitMillis, jint connectionFlags) {
  JavaLangThread *thread = JavaLangThread_currentThread();
  JavaLangStringBuilder *msg = create_JavaLangStringBuilder_init();
  [((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"The connection pool for database '"])) appendWithNSString:((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->label_];
  [msg appendWithNSString:@"' has been unable to grant a connection to thread "];
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithLong:[((JavaLangThread *) nil_chk(thread)) getId]])) appendWithNSString:@" ("])) appendWithNSString:[thread getName]])) appendWithNSString:@") "];
  [((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"with flags 0x"])) appendWithNSString:JavaLangInteger_toHexStringWithInt_(connectionFlags)];
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@" for "])) appendWithFloat:waitMillis * 0.001f])) appendWithNSString:@" seconds.\n"];
  JavaUtilArrayList *requests = create_JavaUtilArrayList_init();
  jint activeConnections = 0;
  jint idleConnections = 0;
  if (![((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) isEmpty]) {
    for (AndroidDatabaseSqliteSQLiteConnection * __strong connection in nil_chk([self->mAcquiredConnections_ keySet])) {
      NSString *description_ = [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) describeCurrentOperationUnsafe];
      if (description_ != nil) {
        [requests addWithId:description_];
        activeConnections += 1;
      }
      else {
        idleConnections += 1;
      }
    }
  }
  jint availableConnections = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  if (self->mAvailablePrimaryConnection_ != nil) {
    availableConnections += 1;
  }
  [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"Connections: "])) appendWithInt:activeConnections])) appendWithNSString:@" active, "];
  [((JavaLangStringBuilder *) nil_chk([msg appendWithInt:idleConnections])) appendWithNSString:@" idle, "];
  [((JavaLangStringBuilder *) nil_chk([msg appendWithInt:availableConnections])) appendWithNSString:@" available.\n"];
  if (![requests isEmpty]) {
    [msg appendWithNSString:@"\nRequests in progress:\n"];
    for (NSString * __strong request in requests) {
      [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"  "])) appendWithNSString:request])) appendWithNSString:@"\n"];
    }
  }
  AndroidUtilLog_wWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, [msg description]);
}

void AndroidDatabaseSqliteSQLiteConnectionPool_wakeConnectionWaitersLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *predecessor = nil;
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterQueue_;
  jboolean primaryConnectionNotAvailable = false;
  jboolean nonPrimaryConnectionNotAvailable = false;
  while (waiter != nil) {
    jboolean unpark = false;
    if (!self->mIsOpen_) {
      unpark = true;
    }
    else {
      @try {
        AndroidDatabaseSqliteSQLiteConnection *connection = nil;
        if (!waiter->mWantPrimaryConnection_ && !nonPrimaryConnectionNotAvailable) {
          connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, waiter->mSql_, waiter->mConnectionFlags_);
          if (connection == nil) {
            nonPrimaryConnectionNotAvailable = true;
          }
        }
        if (connection == nil && !primaryConnectionNotAvailable) {
          connection = AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, waiter->mConnectionFlags_);
          if (connection == nil) {
            primaryConnectionNotAvailable = true;
          }
        }
        if (connection != nil) {
          JreStrongAssign(&waiter->mAssignedConnection_, connection);
          unpark = true;
        }
        else if (nonPrimaryConnectionNotAvailable && primaryConnectionNotAvailable) {
          break;
        }
      }
      @catch (JavaLangRuntimeException *ex) {
        JreStrongAssign(&waiter->mException_, ex);
        unpark = true;
      }
    }
    AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *successor = waiter->mNext_;
    if (unpark) {
      if (predecessor != nil) {
        JreStrongAssign(&predecessor->mNext_, successor);
      }
      else {
        JreStrongAssign(&self->mConnectionWaiterQueue_, successor);
      }
      JreStrongAssign(&waiter->mNext_, nil);
      JavaUtilConcurrentLocksLockSupport_unparkWithJavaLangThread_(waiter->mThread_);
    }
    else {
      predecessor = waiter;
    }
    waiter = successor;
  }
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnection *connection = self->mAvailablePrimaryConnection_;
  if (connection != nil) {
    JreStrongAssign(&self->mAvailablePrimaryConnection_, nil);
    AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
    return connection;
  }
  for (AndroidDatabaseSqliteSQLiteConnection * __strong acquiredConnection in nil_chk([((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) keySet])) {
    if ([((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(acquiredConnection)) isPrimaryConnection]) {
      return nil;
    }
  }
  connection = AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, true);
  AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
  return connection;
}

AndroidDatabaseSqliteSQLiteConnection *AndroidDatabaseSqliteSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, NSString *sql, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnection *connection;
  jint availableCount = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  if (availableCount > 1 && sql != nil) {
    for (jint i = 0; i < availableCount; i++) {
      connection = [self->mAvailableNonPrimaryConnections_ getWithInt:i];
      if ([((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) isPreparedStatementInCacheWithNSString:sql]) {
        [self->mAvailableNonPrimaryConnections_ removeWithInt:i];
        AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
        return connection;
      }
    }
  }
  if (availableCount > 0) {
    connection = [self->mAvailableNonPrimaryConnections_ removeWithInt:availableCount - 1];
    AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
    return connection;
  }
  jint openConnections = [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) size];
  if (self->mAvailablePrimaryConnection_ != nil) {
    openConnections += 1;
  }
  if (openConnections >= self->mMaxConnectionPoolSize_) {
    return nil;
  }
  connection = AndroidDatabaseSqliteSQLiteConnectionPool_openConnectionLockedWithAndroidDatabaseSqliteSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, false);
  AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(self, connection, connectionFlags);
  return connection;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_finishAcquireConnectionLockedWithAndroidDatabaseSqliteSQLiteConnection_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnection *connection, jint connectionFlags) {
  @try {
    jboolean readOnly = (connectionFlags & AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_READ_ONLY) != 0;
    [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(connection)) setOnlyAllowReadOnlyOperationsWithBoolean:readOnly];
    [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) putWithId:connection withId:JreLoadEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL)];
  }
  @catch (JavaLangRuntimeException *ex) {
    AndroidUtilLog_eWithNSString_withNSString_(AndroidDatabaseSqliteSQLiteConnectionPool_TAG, JreStrcat("$@$I", @"Failed to prepare acquired connection for session, closing it: ", connection, @", connectionFlags=", connectionFlags));
    AndroidDatabaseSqliteSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithAndroidDatabaseSqliteSQLiteConnection_(self, connection);
    @throw ex;
  }
}

jboolean AndroidDatabaseSqliteSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, jboolean holdingPrimaryConnection, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterQueue_;
  if (waiter != nil) {
    jint priority = AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
    do {
      if (priority > waiter->mPriority_) {
        break;
      }
      if (holdingPrimaryConnection || !waiter->mWantPrimaryConnection_) {
        return true;
      }
      waiter = waiter->mNext_;
    }
    while (waiter != nil);
  }
  return false;
}

jint AndroidDatabaseSqliteSQLiteConnectionPool_getPriorityWithInt_(jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnectionPool_initialize();
  return (connectionFlags & AndroidDatabaseSqliteSQLiteConnectionPool_CONNECTION_FLAG_INTERACTIVE) != 0 ? 1 : 0;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  if ((((AndroidDatabaseSqliteSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->openFlags_ & AndroidDatabaseSqliteSQLiteDatabase_ENABLE_WRITE_AHEAD_LOGGING) != 0) {
    self->mMaxConnectionPoolSize_ = AndroidDatabaseSqliteSQLiteGlobal_getWALConnectionPoolSize();
  }
  else {
    self->mMaxConnectionPoolSize_ = 1;
  }
}

void AndroidDatabaseSqliteSQLiteConnectionPool_throwIfClosedLocked(AndroidDatabaseSqliteSQLiteConnectionPool *self) {
  if (!self->mIsOpen_) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the connection pool has been closed.");
  }
}

AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *AndroidDatabaseSqliteSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool *self, JavaLangThread *thread, jlong startTime, jint priority, jboolean wantPrimaryConnection, NSString *sql, jint connectionFlags) {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterPool_;
  if (waiter != nil) {
    JreStrongAssign(&self->mConnectionWaiterPool_, waiter->mNext_);
    JreStrongAssign(&waiter->mNext_, nil);
  }
  else {
    waiter = create_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init();
  }
  JreStrongAssign(&waiter->mThread_, thread);
  waiter->mStartTime_ = startTime;
  waiter->mPriority_ = priority;
  waiter->mWantPrimaryConnection_ = wantPrimaryConnection;
  JreStrongAssign(&waiter->mSql_, sql);
  waiter->mConnectionFlags_ = connectionFlags;
  return waiter;
}

void AndroidDatabaseSqliteSQLiteConnectionPool_recycleConnectionWaiterLockedWithAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_(AndroidDatabaseSqliteSQLiteConnectionPool *self, AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *waiter) {
  JreStrongAssign(&((AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNext_, self->mConnectionWaiterPool_);
  JreStrongAssign(&waiter->mThread_, nil);
  JreStrongAssign(&waiter->mSql_, nil);
  JreStrongAssign(&waiter->mAssignedConnection_, nil);
  JreStrongAssign(&waiter->mException_, nil);
  waiter->mNonce_ += 1;
  JreStrongAssign(&self->mConnectionWaiterPool_, waiter);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteConnectionPool)

J2OBJC_INITIALIZED_DEFN(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus)

AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_[3];

@implementation AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus

+ (IOSObjectArray *)values {
  return AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values();
}

+ (AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *)valueOfWithNSString:(NSString *)name {
  return AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_valueOfWithNSString_(name);
}

- (id)copyWithZone:(NSZone *)zone {
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NORMAL", "LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "RECONFIGURE", "LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "DISCARD", "LAndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL), &JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE), &JreEnum(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD), "LAndroidDatabaseSqliteSQLiteConnectionPool;", "Ljava/lang/Enum<Landroid/database/sqlite/SQLiteConnectionPool$AcquiredConnectionStatus;>;" };
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus = { "AcquiredConnectionStatus", "android.database.sqlite", ptrTable, methods, fields, 7, 0x4018, 2, 3, 5, -1, -1, 6, -1 };
  return &_AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus;
}

+ (void)initialize {
  if (self == [AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus class]) {
    size_t objSize = class_getInstanceSize(self);
    size_t allocSize = 3 * objSize;
    uintptr_t ptr = (uintptr_t)calloc(allocSize, 1);
    id e;
    id names[] = {
      @"NORMAL", @"RECONFIGURE", @"DISCARD",
    };
    for (jint i = 0; i < 3; i++) {
      (AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_[i] = e = objc_constructInstance(self, (void *)ptr), ptr += objSize);
      AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(e, names[i], i);
    }
    J2OBJC_SET_INITIALIZED(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus)
  }
}

@end

void AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

IOSObjectArray *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values() {
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  return [IOSObjectArray arrayWithObjects:AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_ count:3 type:AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_class_()];
}

AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_valueOfWithNSString_(NSString *name) {
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  for (int i = 0; i < 3; i++) {
    AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *e = AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus *AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_fromOrdinal(NSUInteger ordinal) {
  AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  if (ordinal >= 3) {
    return nil;
  }
  return AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteConnectionPool_AcquiredConnectionStatus)

@implementation AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)dealloc {
  RELEASE_(mNext_);
  RELEASE_(mThread_);
  RELEASE_(mSql_);
  RELEASE_(mAssignedConnection_);
  RELEASE_(mException_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mNext_", "LAndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mThread_", "LJavaLangThread;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mStartTime_", "J", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mPriority_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mWantPrimaryConnection_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mSql_", "LNSString;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mConnectionFlags_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mAssignedConnection_", "LAndroidDatabaseSqliteSQLiteConnection;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mException_", "LJavaLangRuntimeException;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mNonce_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidDatabaseSqliteSQLiteConnectionPool;" };
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter = { "ConnectionWaiter", "android.database.sqlite", ptrTable, methods, fields, 7, 0x1a, 1, 10, 0, -1, -1, -1, -1 };
  return &_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter;
}

@end

void AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *self) {
  NSObject_init(self);
}

AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *new_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init() {
  J2OBJC_NEW_IMPL(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, init)
}

AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter *create_AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter_init() {
  J2OBJC_CREATE_IMPL(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteConnectionPool_ConnectionWaiter)
